#!/usr/bin/env python3

import binascii
import os
import sys
import struct
import socket
from google.protobuf import message as _message
import aesm_pb2

sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
from generated_offsets import *

""" Utilities """

def int_to_bytes(i):
    b = b""
    l = 0
    while i > 0:
        b = b + bytes([i % 256])
        i = i // 256
        l = l + 1
    return b

def bytes_to_int(b):
    i = 0
    for c in b:
        i = i * 256 + c
    return i


""" Reading Sigstruct """

def read_sigstruct(sig):
    # field format: (offset, type, value)
    fields = dict()

    # SGX_ARCH_SIGSTRUCT_
    fields['date']      = (SGX_ARCH_SIGSTRUCT_DATE,
                               "<HBB", 'year', 'month', 'day')

    fields['modulus']   = (SGX_ARCH_SIGSTRUCT_MODULUS, "384s", 'modulus')
    fields['exponent']  = (SGX_ARCH_SIGSTRUCT_EXPONENT, "<L",   'exponent')
    fields['signature'] = (SGX_ARCH_SIGSTRUCT_SIGNATURE, "384s", 'signature')

    fields['miscs']     = (SGX_ARCH_SIGSTRUCT_MISCSELECT, "4s",   'miscs')
    fields['miscmask']  = (SGX_ARCH_SIGSTRUCT_MISCSELECT_MASK,
                               "4s",   'miscmask')
    fields['attrs']     = (SGX_ARCH_SIGSTRUCT_ATTRIBUTES,
                               "8s8s", 'flags', 'xfrms')
    fields['attrmask']  = (SGX_ARCH_SIGSTRUCT_ATTRIBUTES_MASK,
                               "8s8s", 'flagmask', 'xfrmmask')
    fields['mrenclave'] = (SGX_ARCH_SIGSTRUCT_ENCLAVE_HASH, "32s",  'mrenclave')
    fields['isvprodid'] = (SGX_ARCH_SIGSTRUCT_ISVPRODID, "<H",   'isvprodid')
    fields['isvsvn']    = (SGX_ARCH_SIGSTRUCT_ISVSVN, "<H",   'isvsvn')

    attr = dict()
    for key, field in list(fields.items()):
        values = struct.unpack_from(field[1], sig, field[0])

        for i in range(len(values)):
            attr[field[i + 2]] = values[i]

    return attr

""" Connect with AESMD """

def connect_aesmd(attr):
    req_msg = aesm_pb2.GetTokenReq()
    req_msg.req.signature = attr['mrenclave']
    req_msg.req.key = attr['modulus']
    req_msg.req.attributes = attr['flags'] + attr['xfrms']
    req_msg.req.timeout = 10000

    req_msg_raw = req_msg.SerializeToString()

    aesm_service = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    connected = False

    # try to connect to the unnamed socket (for PSW 1.6 and 1.7)
    if not connected:
        try:
            aesm_service.connect("\0sgx_aesm_socket_base" + "\0" * 87)
            connected = True
        except socket.error:
            pass

    # try to connect to the named socket (for PSW 1.8+)
    if not connected:
        try:
            aesm_service.connect("/var/run/aesmd/aesm.socket")
            connected = True
        except socket.error:
            pass

    if not connected:
        raise socket.error("Cannot connect to the AESMD service")

    aesm_service.send(struct.pack("<I", len(req_msg_raw)))
    aesm_service.send(req_msg_raw)

    ret_msg_size = struct.unpack("<I", aesm_service.recv(4))[0]
    ret_msg = aesm_pb2.GetTokenRet()
    ret_msg_raw = aesm_service.recv(ret_msg_size)
    ret_msg.ParseFromString(ret_msg_raw)

    if ret_msg.ret.error != 0:
        raise Exception("Failed. (Error Code = %d)" % (ret_msg.ret.error))

    return ret_msg.ret.token

""" Main Program """

options = {
#       Option name : (Required  Value)
        'output':    (True,    'output'),
        'sig':       (True,    'sigstruct file'),
    }

def usage():
    usage_message = 'USAGE: ' + sys.argv[0] + ' -help|-h'

    for opt, optval in list(options.items()):
        if not optval[0]:
            usage_message += '['
        usage_message += '|-' + opt
        if optval[1]:
            usage_message += ' <' + optval[1] + '>'
        if not optval[0]:
            usage_message += ']'

    print(usage_message, file=sys.stderr)
    os._exit(-1)

def parse_args():
    args = dict()
    for opt, optval in list(options.items()):
        if optval[1] is None:
            args[opt] = False

    i = 1
    while i < len(sys.argv):
        got = sys.argv[i]

        if got == '-help' or got == '-h':
            usage()

        invalid = True
        for opt, optval in list(options.items()):
            if got != '-' + opt:
                continue

            if optval[1] is not None:
                i += 1
                if i == len(sys.argv):
                    print("Option %s needs a value." % (opt), file=sys.stderr)
                    usage()
                args[opt] = sys.argv[i]
            else:
                args[opt] = True

            invalid = False
            break

        if invalid:
            print("Unknown option: %s." % (got[1:]), file=sys.stderr)
            usage()
        i += 1

    for opt, optval in list(options.items()):
        if optval[0] and opt not in args:
            print("Must specify %s <%s>." % (opt, optval[1]), file=sys.stderr)
            usage()

    return args

if __name__ == "__main__":

    # Parse arguments
    args = parse_args()

    attr = read_sigstruct(open(args['sig'], 'rb').read())

    print("Attributes:")
    print("    mrenclave: %s" % binascii.hexlify(attr['mrenclave']).decode())
    print("    isvprodid: %d" % (attr['isvprodid']))
    print("    isvsvn:    %d" % (attr['isvsvn']))
    print("    flags:     %016x" % (bytes_to_int(attr['flags'])))
    print("    xfrms:     %016x" % (bytes_to_int(attr['xfrms'])))
    print("    miscs:     %08x"  % (bytes_to_int(attr['miscs'])))
    print("    miscmask:  %08x"  % (bytes_to_int(attr['miscmask'])))
    print("    modulus:   %s..." % (binascii.hexlify(attr['modulus']).decode()[:32]))
    print("    exponent:  %d" % (attr['exponent']))
    print("    signature: %s..." % (binascii.hexlify(attr['signature']).decode()[:32]))

    token = connect_aesmd(attr)
    open(args['output'], 'wb').write(token)
