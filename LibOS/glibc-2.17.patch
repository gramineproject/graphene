diff --git a/Makeconfig b/Makeconfig
index 70a3d9d..2c543c3 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -718,7 +718,8 @@ endif	# $(+cflags) == ""
 +sysdep-includes = $(addprefix -I,$(+sysdep_dirs))
 +includes = -I$(..)include $(if $(subdir),$(objpfx:%/=-I%)) \
 	    $(+sysdep-includes) $(includes) \
-	    $(patsubst %/,-I%,$(..)) $(libio-include) -I. $(sysincludes)
+	    $(patsubst %/,-I%,$(..)) $(libio-include) -I. $(sysincludes) \
+	    -I$(common-objpfx)../shim/include
 
 # Since libio has several internal header files, we use a -I instead
 # of many little headers in the include directory.
@@ -987,7 +988,7 @@ all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
 	      stdlib stdio-common libio malloc string wcsmbs time dirent    \
 	      grp pwd posix io termios resource misc socket sysvipc gmon    \
 	      gnulib iconv iconvdata wctype manual shadow gshadow po argp   \
-	      crypt nss localedata timezone rt conform debug		    \
+	      crypt nss localedata timezone rt conform debug libos	    \
 	      $(add-on-subdirs) dlfcn elf
 
 ifndef avoid-generated
diff --git a/Makefile b/Makefile
index 6c1e392..3df0ac6 100644
--- a/Makefile
+++ b/Makefile
@@ -197,6 +197,8 @@ $(inst_includedir)/gnu/stubs.h: $(+force)
 install-others-nosubdir: $(installed-stubs)
 endif
 
+# For Graphene
+CFLAGS-syscalldb.c = -fPIC
 
 # Since stubs.h is never needed when building the library, we simplify the
 # hairy installation process by producing it in place only as the last part
diff --git a/Versions.def b/Versions.def
index 3c9e0ae..034ab2b 100644
--- a/Versions.def
+++ b/Versions.def
@@ -39,6 +39,7 @@ libc {
   GCC_3.0
 %endif
   GLIBC_PRIVATE
+  SHIM
 }
 libcrypt {
   GLIBC_2.0
@@ -48,6 +49,7 @@ libdl {
   GLIBC_2.1
   GLIBC_2.3.3
   GLIBC_2.3.4
+  SHIM
 }
 libm {
   GLIBC_2.0
@@ -100,6 +102,7 @@ libpthread {
   GLIBC_2.11
   GLIBC_2.12
   GLIBC_PRIVATE
+  SHIM
 }
 libresolv {
   GLIBC_2.0
@@ -127,6 +130,7 @@ ld {
   GLIBC_2.3
   GLIBC_2.4
   GLIBC_PRIVATE
+  SHIM
 }
 libthread_db {
   GLIBC_2.1.3
@@ -140,3 +144,6 @@ libanl {
 libcidn {
   GLIBC_PRIVATE
 }
+liblibos {
+  GLIBC_2.12
+}
diff --git a/configure b/configure
index 8799b7d..22e4c2c 100755
--- a/configure
+++ b/configure
@@ -636,7 +636,8 @@ SED
 MAKEINFO
 MSGFMT
 MAKE
-LD
+LD_GOLD
+LD_BFD
 AS
 MIG
 OBJCOPY
@@ -4792,17 +4793,22 @@ if test $ac_verc_fail = yes; then
   AS=: critic_missing="$critic_missing as"
 fi
 
-for ac_prog in $LD
+LD_BFD=
+LD_GOLD=
+ld_is_gold="`$LD --version | sed -n 's/^GNU \(gold\).*$/\1/p'`"
+if test -z "$ld_is_gold"; then
+  LD_BFD=$LD
+  for ac_prog in $LD_BFD
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_LD+:} false; then :
+if ${ac_cv_prog_LD_BFD+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$LD"; then
-  ac_cv_prog_LD="$LD" # Let the user override the test.
+  if test -n "$LD_BFD"; then
+  ac_cv_prog_LD_BFD="$LD_BFD" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -4811,7 +4817,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LD="$ac_prog"
+    ac_cv_prog_LD_BFD="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -4821,26 +4827,26 @@ IFS=$as_save_IFS
 
 fi
 fi
-LD=$ac_cv_prog_LD
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
+LD_BFD=$ac_cv_prog_LD_BFD
+if test -n "$LD_BFD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD_BFD" >&5
+$as_echo "$LD_BFD" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
-  test -n "$LD" && break
+  test -n "$LD_BFD" && break
 done
 
-if test -z "$LD"; then
+if test -z "$LD_BFD"; then
   ac_verc_fail=yes
 else
   # Found it, now check the version.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking version of $LD" >&5
-$as_echo_n "checking version of $LD... " >&6; }
-  ac_prog_version=`$LD --version 2>&1 | sed -n 's/^.*GNU ld.* \([0-9][0-9]*\.[0-9.]*\).*$/\1/p'`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking version of $LD_BFD" >&5
+$as_echo_n "checking version of $LD_BFD... " >&6; }
+  ac_prog_version=`$LD_BFD --version 2>&1 | sed -n 's/^.*GNU ld.* \([0-9][0-9]*\.[0-9.]*\).*$/\1/p'`
   case $ac_prog_version in
     '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
     2.1[0-9][0-9]*|2.[2-9][0-9]*|[3-9].*|[1-9][0-9]*)
@@ -4852,9 +4858,80 @@ $as_echo_n "checking version of $LD... " >&6; }
 $as_echo "$ac_prog_version" >&6; }
 fi
 if test $ac_verc_fail = yes; then
-  LD=: critic_missing="$critic_missing ld"
+  LD_BFD=:
 fi
 
+else
+# Accept gold 1.11 or higher.
+  LD_GOLD=$LD
+  for ac_prog in $LD_GOLD
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_LD_GOLD+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LD_GOLD"; then
+  ac_cv_prog_LD_GOLD="$LD_GOLD" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LD_GOLD="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LD_GOLD=$ac_cv_prog_LD_GOLD
+if test -n "$LD_GOLD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD_GOLD" >&5
+$as_echo "$LD_GOLD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$LD_GOLD" && break
+done
+
+if test -z "$LD_GOLD"; then
+  ac_verc_fail=yes
+else
+  # Found it, now check the version.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking version of $LD_GOLD" >&5
+$as_echo_n "checking version of $LD_GOLD... " >&6; }
+  ac_prog_version=`$LD_GOLD --version 2>&1 | sed -n 's/^.*GNU gold.* \([0-9][0-9]*\.[0-9.]*\).*$/\1/p'`
+  case $ac_prog_version in
+    '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+    1.1[1-9]*|1.[2-9][0-9]*|1.1[0-9][0-9]*|[2-9].*|[1-9][0-9]*)
+       ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
+    *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
+
+  esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_prog_version" >&5
+$as_echo "$ac_prog_version" >&6; }
+fi
+if test $ac_verc_fail = yes; then
+  LD_GOLD=:
+fi
+
+fi
+# Neither ld nor gold are new enough.
+if test -z "$LD_BFD" && test -z "$LD_GOLD"; then
+  critic_missing="$critic_missing ld"
+fi
 
 # These programs are version sensitive.
 
@@ -6670,6 +6747,16 @@ $as_echo "$libc_cv_use_default_link" >&6; }
   use_default_link=$libc_cv_use_default_link
 fi
 
+# The gold linker has no builtin default linker script,
+# and the fallback of editing the builtin linker
+# script is not available. Therefore if use_default_link
+# is `no' then we can't use gold. This check is independent
+# of gold's version and is used to sanity check that the
+# linker continues to produce a useful shared link.
+if test "$ld_is_gold" && test "$use_default_link" = "no"; then
+  as_fn_error $? "$LD did not generate a useful shared link. Try using GNU ld.bfd?" "$LINENO" 5
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking linker output format" >&5
 $as_echo_n "checking linker output format... " >&6; }
 if ${libc_cv_output_format+:} false; then :
@@ -6688,6 +6775,17 @@ fi
 $as_echo "$libc_cv_output_format" >&6; }
 
 
+# The gold linker has no builtin default linker script,
+# and the fallback of parsing the builtin linker
+# script to determine the target is not available.
+# Therefore if libc_cv_output_format is `unknown' then
+# we can't use gold. This check is independent of gold's
+# version and is used to sanity check that the linker
+# continues to support --print-output-format.
+if test "$ld_is_gold" && test "$libc_cv_output_format" = "unknown"; then
+  as_fn_error $? "$LD did not support --print-output-format. Try using GNU ld.bfd?" "$LINENO" 5
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -fno-toplevel-reorder -fno-section-anchors" >&5
 $as_echo_n "checking for -fno-toplevel-reorder -fno-section-anchors... " >&6; }
 if ${libc_cv_fno_toplevel_reorder+:} false; then :
diff --git a/configure.in b/configure.in
index d369382..38ff3cd 100644
--- a/configure.in
+++ b/configure.in
@@ -924,9 +924,25 @@ AC_SUBST(MIG)dnl Needed by sysdeps/mach/configure.in
 AC_CHECK_PROG_VER(AS, $AS, --version,
 		  [GNU assembler.* \([0-9]*\.[0-9.]*\)],
 		  [2.1[0-9][0-9]*|2.[2-9][0-9]*|[3-9].*|[1-9][0-9]*], AS=: critic_missing="$critic_missing as")
-AC_CHECK_PROG_VER(LD, $LD, --version,
+LD_BFD=
+LD_GOLD=
+ld_is_gold="`$LD --version | sed -n 's/^GNU \(gold\).*$/\1/p'`"
+if test -z "$ld_is_gold"; then
+  LD_BFD=$LD
+  AC_CHECK_PROG_VER(LD_BFD, $LD_BFD, --version,
 		  [GNU ld.* \([0-9][0-9]*\.[0-9.]*\)],
-		  [2.1[0-9][0-9]*|2.[2-9][0-9]*|[3-9].*|[1-9][0-9]*], LD=: critic_missing="$critic_missing ld")
+		  [2.1[0-9][0-9]*|2.[2-9][0-9]*|[3-9].*|[1-9][0-9]*],LD_BFD=:)
+else
+# Accept gold 1.11 or higher.
+  LD_GOLD=$LD
+  AC_CHECK_PROG_VER(LD_GOLD, $LD_GOLD, --version,
+		  [GNU gold.* \([0-9][0-9]*\.[0-9.]*\)],
+		  [1.1[1-9]*|1.[2-9][0-9]*|1.1[0-9][0-9]*|[2-9].*|[1-9][0-9]*],LD_GOLD=:)
+fi
+# Neither ld nor gold are new enough.
+if test -z "$LD_BFD" && test -z "$LD_GOLD"; then
+  critic_missing="$critic_missing ld"
+fi
 
 # These programs are version sensitive.
 AC_CHECK_TOOL_PREFIX
@@ -1635,6 +1651,16 @@ $ac_try"
   use_default_link=$libc_cv_use_default_link
 fi
 
+# The gold linker has no builtin default linker script,
+# and the fallback of editing the builtin linker
+# script is not available. Therefore if use_default_link
+# is `no' then we can't use gold. This check is independent
+# of gold's version and is used to sanity check that the
+# linker continues to produce a useful shared link.
+if test "$ld_is_gold" && test "$use_default_link" = "no"; then
+  AC_MSG_ERROR([$LD did not generate a useful shared link. Try using GNU ld.bfd?])
+fi
+
 AC_CACHE_CHECK(linker output format, libc_cv_output_format, [dnl
 if libc_cv_output_format=`
 ${CC-cc} -nostartfiles -nostdlib -Wl,--print-output-format 2>&AS_MESSAGE_LOG_FD`
@@ -1646,6 +1672,17 @@ fi
 test -n "$libc_cv_output_format" || libc_cv_output_format=unknown])
 AC_SUBST(libc_cv_output_format)
 
+# The gold linker has no builtin default linker script,
+# and the fallback of parsing the builtin linker
+# script to determine the target is not available.
+# Therefore if libc_cv_output_format is `unknown' then
+# we can't use gold. This check is independent of gold's
+# version and is used to sanity check that the linker
+# continues to support --print-output-format.
+if test "$ld_is_gold" && test "$libc_cv_output_format" = "unknown"; then
+  AC_MSG_ERROR([$LD did not support --print-output-format. Try using GNU ld.bfd?])
+fi
+
 AC_CACHE_CHECK(for -fno-toplevel-reorder -fno-section-anchors, libc_cv_fno_toplevel_reorder, [dnl
 cat > conftest.c <<EOF
 int foo;
diff --git a/dlfcn/Versions b/dlfcn/Versions
index 97902f0..c1874c1 100644
--- a/dlfcn/Versions
+++ b/dlfcn/Versions
@@ -14,4 +14,7 @@ libdl {
   GLIBC_PRIVATE {
     _dlfcn_hook;
   }
+  SHIM {
+    syscalldb;
+  }
 }
diff --git a/elf/Makefile b/elf/Makefile
index 6c7bc97..b51a799 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -21,7 +21,7 @@ subdir		:= elf
 
 include ../Makeconfig
 
-headers		= elf.h bits/elfclass.h link.h bits/link.h
+headers		= elf.h bits/elfclass.h link.h bits/link.h syscalldb.h
 routines	= $(dl-routines) dl-support dl-iteratephdr \
 		  dl-addr enbl-secure dl-profstub \
 		  dl-origin dl-libc dl-sym dl-tsd dl-sysdep
@@ -31,7 +31,8 @@ routines	= $(dl-routines) dl-support dl-iteratephdr \
 dl-routines	= $(addprefix dl-,load lookup object reloc deps hwcaps \
 				  runtime error init fini debug misc \
 				  version profile conflict tls origin scope \
-				  execstack caller open close trampoline)
+				  execstack caller open close trampoline) \
+		  syscalldb syscallas
 ifeq (yes,$(use-ldconfig))
 dl-routines += dl-cache
 endif
diff --git a/elf/Versions b/elf/Versions
index 87e27c5..a0e345b 100644
--- a/elf/Versions
+++ b/elf/Versions
@@ -24,14 +24,15 @@ libc {
     _dl_open_hook;
     __libc_dlopen_mode; __libc_dlsym; __libc_dlclose;
   }
+  SHIM {
+    syscalldb;
+  }
 }
 
 ld {
   GLIBC_2.0 {
     # Function from libc.so which must be shared with libc.
     calloc; free; malloc; realloc; __libc_memalign;
-
-    _r_debug;
   }
   GLIBC_2.1 {
     # functions used in other libraries
@@ -59,8 +60,11 @@ ld {
     _dl_tls_setup; _dl_rtld_di_serinfo;
     _dl_make_stack_executable;
     # Only here for gdb while a better method is developed.
-    _dl_debug_state;
+    __libc_r_debug; __libc_dl_debug_state;
     # Pointer protection.
     __pointer_chk_guard;
   }
+  SHIM {
+    syscalldb; glibc_vers_2_17; register_library;
+  }
 }
diff --git a/elf/circleload1.c b/elf/circleload1.c
index 990ff84..ccf92d3 100644
--- a/elf/circleload1.c
+++ b/elf/circleload1.c
@@ -5,7 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 static int
 check_loaded_objects (const char **loaded)
diff --git a/elf/dl-close.c b/elf/dl-close.c
index cda0e71..580e1e2 100644
--- a/elf/dl-close.c
+++ b/elf/dl-close.c
@@ -468,7 +468,7 @@ _dl_close_worker (struct link_map *map)
   /* Notify the debugger we are about to remove some loaded objects.  */
   struct r_debug *r = _dl_debug_initialize (0, nsid);
   r->r_state = RT_DELETE;
-  _dl_debug_state ();
+  __libc_dl_debug_state ();
   LIBC_PROBE (unmap_start, 2, nsid, r);
 
   if (unload_global)
@@ -742,7 +742,7 @@ _dl_close_worker (struct link_map *map)
 
   /* Notify the debugger those objects are finalized and gone.  */
   r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
+  __libc_dl_debug_state ();
   LIBC_PROBE (unmap_complete, 2, nsid, r);
 
   /* Recheck if we need to retry, release the lock.  */
diff --git a/elf/dl-debug.c b/elf/dl-debug.c
index 4106e42..b95bd27 100644
--- a/elf/dl-debug.c
+++ b/elf/dl-debug.c
@@ -35,7 +35,7 @@ extern const int verify_link_map_members[(VERIFY_MEMBER (l_addr)
    normally finds it via the DT_DEBUG entry in the dynamic section, but in
    a statically-linked program there is no dynamic section for the debugger
    to examine and it looks for this particular symbol name.  */
-struct r_debug _r_debug;
+struct r_debug __libc_r_debug __attribute__((weak));
 
 
 /* Initialize _r_debug if it has not already been done.  The argument is
@@ -49,7 +49,7 @@ _dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
   struct r_debug *r;
 
   if (ns == LM_ID_BASE)
-    r = &_r_debug;
+    r = &__libc_r_debug;
   else
     r = &GL(dl_ns)[ns]._ns_debug;
 
@@ -57,9 +57,9 @@ _dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
     {
       /* Tell the debugger where to find the map of loaded objects.  */
       r->r_version = 1	/* R_DEBUG_VERSION XXX */;
-      r->r_ldbase = ldbase ?: _r_debug.r_ldbase;
+      r->r_ldbase = ldbase ?: __libc_r_debug.r_ldbase;
       r->r_map = (void *) GL(dl_ns)[ns]._ns_loaded;
-      r->r_brk = (ElfW(Addr)) &_dl_debug_state;
+      r->r_brk = (ElfW(Addr)) &__libc_dl_debug_state;
     }
 
   return r;
@@ -71,7 +71,7 @@ _dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
    examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
    for this particular symbol name in the PT_INTERP file.  */
 void
-_dl_debug_state (void)
+__libc_dl_debug_state (void)
 {
 }
-rtld_hidden_def (_dl_debug_state)
+__attribute__((weak));
diff --git a/elf/dl-load.c b/elf/dl-load.c
index 70fe78f..4ec655a 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -39,6 +39,8 @@
 
 #include <dl-dst.h>
 
+#include <glibc-version.h>
+
 /* On some systems, no flag bits are given to specify file mapping.  */
 #ifndef MAP_FILE
 # define MAP_FILE	0
@@ -896,7 +898,7 @@ lose (int code, int fd, const char *name, char *realname, struct link_map *l,
   if (r != NULL)
     {
       r->r_state = RT_CONSISTENT;
-      _dl_debug_state ();
+      __libc_dl_debug_state ();
       LIBC_PROBE (map_failed, 2, nsid, r);
     }
 
@@ -1042,7 +1044,7 @@ _dl_map_object_from_fd (const char *name, int fd, struct filebuf *fbp,
 	 call _dl_debug_initialize in a static program in case dynamic
 	 linking has not been used before.  */
       r->r_state = RT_ADD;
-      _dl_debug_state ();
+      __libc_dl_debug_state ();
       LIBC_PROBE (map_start, 2, nsid, r);
       make_consistent = true;
     }
@@ -1585,6 +1587,9 @@ cannot enable executable stack as shared object requires");
   DL_AFTER_LOAD (l);
 #endif
 
+  /* register the library to SHIM */
+  register_library(l->l_name, l->l_addr);
+
   /* Now that the object is fully initialized add it to the object list.  */
   _dl_add_to_namespace_list (l, nsid);
 
diff --git a/elf/dl-open.c b/elf/dl-open.c
index 9c39a34..a21f51e 100644
--- a/elf/dl-open.c
+++ b/elf/dl-open.c
@@ -294,7 +294,7 @@ dl_open_worker (void *a)
   /* Notify the debugger all new objects are now ready to go.  */
   struct r_debug *r = _dl_debug_initialize (0, args->nsid);
   r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
+  __libc_dl_debug_state ();
   LIBC_PROBE (map_complete, 3, args->nsid, r, new);
 
   /* Print scope information.  */
diff --git a/elf/link.h b/elf/link.h
index 11136cc..db5c4e3 100644
--- a/elf/link.h
+++ b/elf/link.h
@@ -64,7 +64,7 @@ struct r_debug
   };
 
 /* This is the instance of that structure used by the dynamic linker.  */
-extern struct r_debug _r_debug;
+extern struct r_debug __libc_r_debug;
 
 /* This symbol refers to the "dynamic structure" in the `.dynamic' section
    of whatever module refers to `_DYNAMIC'.  So, to find its own
diff --git a/elf/loadtest.c b/elf/loadtest.c
index 727469b..568ddef 100644
--- a/elf/loadtest.c
+++ b/elf/loadtest.c
@@ -70,7 +70,7 @@ static const struct
 
 #include <include/link.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 #define OUT \
   for (map = MAPS; map != NULL; map = map->l_next)		      \
diff --git a/elf/neededtest.c b/elf/neededtest.c
index 3cea499..e098d48 100644
--- a/elf/neededtest.c
+++ b/elf/neededtest.c
@@ -5,7 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 static int
 check_loaded_objects (const char **loaded)
diff --git a/elf/neededtest2.c b/elf/neededtest2.c
index 17c75f2..5a73a95 100644
--- a/elf/neededtest2.c
+++ b/elf/neededtest2.c
@@ -5,7 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 static int
 check_loaded_objects (const char **loaded)
diff --git a/elf/neededtest3.c b/elf/neededtest3.c
index 41970cf..5126615 100644
--- a/elf/neededtest3.c
+++ b/elf/neededtest3.c
@@ -5,7 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 static int
 check_loaded_objects (const char **loaded)
diff --git a/elf/neededtest4.c b/elf/neededtest4.c
index 0ae0b7f..f883910 100644
--- a/elf/neededtest4.c
+++ b/elf/neededtest4.c
@@ -5,7 +5,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 static int
 check_loaded_objects (const char **loaded)
diff --git a/elf/rtld.c b/elf/rtld.c
index b0126e5..2fb4fe9 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -356,6 +356,23 @@ _dl_start_final (void *arg, struct dl_start_final_info *info)
   return start_addr;
 }
 
+/* For graphene, check if glibc version match to the compatible SHIM
+   library. If not, tell the user to update glibc. */
+#include "glibc-version.h"
+
+volatile const int glibc_vers_2_17 __attribute__((weak)) = GLIBC_VERSION_2_17;
+
+static void __attribute__((noinline,optimize("-O0")))
+check_glibc_version (void)
+{
+  if (glibc_vers_2_17 != GLIBC_VERSION_2_17)
+    {
+      _dl_fatal_printf ("Warning from Graphene: "
+			"Glibc version is incorrect. Please rebuild Glibc.\n");
+      _exit (1);
+    }
+}
+
 static ElfW(Addr) __attribute_used__ internal_function
 _dl_start (void *arg)
 {
@@ -546,6 +563,9 @@ _dl_start (void *arg)
      therefore need not test whether we have to allocate the array
      for the relocation results (as done in dl-reloc.c).  */
 
+  /* For Graphene, check if the glibc version is correct. */
+  check_glibc_version();
+
   /* Now life is sane; we can call functions and access global data.
      Set up to use the operating system facilities, and find out from
      the operating system's program loader where to find the program
@@ -1230,9 +1250,20 @@ of this helper program; chances are you did not intend to run this program.\n\
 	    main_map->l_map_end = allocend;
 	  if ((ph->p_flags & PF_X) && allocend > main_map->l_text_end)
 	    main_map->l_text_end = allocend;
+
+#if 0
+	  ElfW(Addr) mapend = (allocend + GLRO(dl_pagesize) - 1)
+		               & ~(GLRO(dl_pagesize) - 1);
+	  int prot = ((ph->p_flags & PF_R) ? PROT_READ  : 0)|
+	             ((ph->p_flags & PF_W) ? PROT_WRITE : 0)|
+	             ((ph->p_flags & PF_X) ? PROT_EXEC  : 0);
+	  __mmap ((void *) mapstart, mapend - mapstart,
+		  prot,
+		  MAP_ANON|MAP_PRIVATE|MAP_FIXED|0x20000000,
+		  -1, 0);
+#endif
 	}
 	break;
-
       case PT_TLS:
 	if (ph->p_memsz > 0)
 	  {
@@ -1378,13 +1409,31 @@ of this helper program; chances are you did not intend to run this program.\n\
   /* PT_GNU_RELRO is usually the last phdr.  */
   size_t cnt = rtld_ehdr->e_phnum;
   while (cnt-- > 0)
+  {
     if (rtld_phdr[cnt].p_type == PT_GNU_RELRO)
       {
 	GL(dl_rtld_map).l_relro_addr = rtld_phdr[cnt].p_vaddr;
 	GL(dl_rtld_map).l_relro_size = rtld_phdr[cnt].p_memsz;
-	break;
       }
 
+#if 0
+    if (rtld_phdr[cnt].p_type == PT_LOAD)
+      {
+	ElfW(Addr) mapstart = rtld_phdr[cnt].p_vaddr & ~(GLRO(dl_pagesize) - 1);
+	ElfW(Addr) mapend = (rtld_phdr[cnt].p_vaddr + rtld_phdr[cnt].p_memsz
+		             + GLRO(dl_pagesize) - 1)
+		             & ~(GLRO(dl_pagesize) - 1);
+	int prot = ((rtld_phdr[cnt].p_flags & PF_R) ? PROT_READ  : 0)|
+	           ((rtld_phdr[cnt].p_flags & PF_W) ? PROT_WRITE : 0)|
+	           ((rtld_phdr[cnt].p_flags & PF_X) ? PROT_EXEC  : 0);
+	__mmap ((void *) mapstart, mapend - mapstart,
+		prot,
+		MAP_ANON|MAP_PRIVATE|MAP_FIXED|0x20000000,
+		-1, 0);
+      }
+#endif
+  }
+
   /* Add the dynamic linker to the TLS list if it also uses TLS.  */
   if (GL(dl_rtld_map).l_tls_blocksize != 0)
     /* Assign a module ID.  Do this before loading any audit modules.  */
@@ -1585,7 +1634,7 @@ ERROR: ld.so: object '%s' cannot be loaded as audit interface: %s; ignored.\n",
 
   /* We start adding objects.  */
   r->r_state = RT_ADD;
-  _dl_debug_state ();
+  __libc_dl_debug_state ();
   LIBC_PROBE (init_start, 2, LM_ID_BASE, r);
 
   /* Auditing checkpoint: we are ready to signal that the initial map
@@ -2305,7 +2354,7 @@ ERROR: ld.so: object '%s' cannot be loaded as audit interface: %s; ignored.\n",
      the address since by now the variable might be in another object.  */
   r = _dl_debug_initialize (0, LM_ID_BASE);
   r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
+  __libc_dl_debug_state ();
   LIBC_PROBE (init_complete, 2, LM_ID_BASE, r);
 
 #if defined USE_LDCONFIG && !defined MAP_COPY
diff --git a/elf/unload.c b/elf/unload.c
index 4566f22..73046de 100644
--- a/elf/unload.c
+++ b/elf/unload.c
@@ -9,7 +9,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 #define OUT \
   for (map = MAPS; map != NULL; map = map->l_next)			      \
diff --git a/elf/unload2.c b/elf/unload2.c
index eef2bfd..a21d2ac 100644
--- a/elf/unload2.c
+++ b/elf/unload2.c
@@ -6,7 +6,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#define MAPS ((struct link_map *) _r_debug.r_map)
+#define MAPS ((struct link_map *) __libc_r_debug.r_map)
 
 #define OUT \
   for (map = MAPS; map != NULL; map = map->l_next)			      \
diff --git a/nptl/Makefile b/nptl/Makefile
index e33432e..8ec263f 100644
--- a/nptl/Makefile
+++ b/nptl/Makefile
@@ -20,7 +20,7 @@
 #
 subdir	:= nptl
 
-headers := pthread.h semaphore.h bits/semaphore.h
+headers := pthread.h semaphore.h bits/semaphore.h syscalldb.h
 
 extra-libs := libpthread
 extra-libs-others := $(extra-libs)
diff --git a/nptl/Versions b/nptl/Versions
index 6a10375..4a1eb35 100644
--- a/nptl/Versions
+++ b/nptl/Versions
@@ -31,6 +31,9 @@ libc {
     # Internal libc interface to libpthread
     __libc_dl_error_tsd;
   }
+  SHIM {
+    syscalldb;
+  }
 }
 
 libpthread {
@@ -257,4 +260,8 @@ libpthread {
     __pthread_clock_gettime; __pthread_clock_settime;
     __pthread_unwind; __pthread_get_minstack;
   }
+
+  SHIM {
+    syscalldb;
+  }
 }
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index 197dfa7..6cf8fa6 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -398,8 +398,11 @@ start_thread (void *arg)
 # error "to do"
 #endif
   assert (freesize < pd->stackblock_size);
+  /* XXX: may not be necessary */
+#if 0
   if (freesize > PTHREAD_STACK_MIN)
     __madvise (pd->stackblock, freesize - PTHREAD_STACK_MIN, MADV_DONTNEED);
+#endif
 
   /* If the thread is detached free the TCB.  */
   if (IS_DETACHED (pd))
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
index 31bb08b..4729064 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
@@ -111,7 +111,8 @@ ENTRY(__pthread_disable_asynccancel)
 	xorq	%r10, %r10
 	addq	$CANCELHANDLING, %rdi
 	LOAD_PRIVATE_FUTEX_WAIT (%esi)
-	syscall
+	SYSCALL
+
 	movl	%fs:CANCELHANDLING, %eax
 	jmp	3b
 END(__pthread_disable_asynccancel)
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c b/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c
index dedbabd..5bd873e 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/fork.c
@@ -21,10 +21,20 @@
 #include <sysdep.h>
 #include <tls.h>
 
-
-#define ARCH_FORK() \
+/* In Graphene, we prefer to call fork system call directly than clone */
+#if USE_clone_FOR_fork
+# define ARCH_FORK() \
   INLINE_SYSCALL (clone, 4,						      \
 		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,     \
 		  NULL, &THREAD_SELF->tid)
+#else
+# define ARCH_FORK() \
+ ({ unsigned long ret = INLINE_SYSCALL (fork, 0);	\
+    if (!ret) {						\
+	pid_t pid = INLINE_SYSCALL (getpid, 0);		\
+	THREAD_SETMEM (THREAD_SELF, pid, pid);		\
+	THREAD_SETMEM (THREAD_SELF, tid, pid);		\
+    } ret; })
+#endif
 
 #include "../fork.c"
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
index dc95421..a772f66 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
@@ -90,7 +90,7 @@ __lll_lock_wait_private:
 
 1:	LIBC_PROBE (lll_lock_wait_private, 1, %rdi)
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 2:	movl	%edx, %eax
 	xchgl	%eax, (%rdi)	/* NB:	 lock is implied */
@@ -130,7 +130,7 @@ __lll_lock_wait:
 
 1:	LIBC_PROBE (lll_lock_wait, 2, %rdi, %rsi)
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 2:	movl	%edx, %eax
 	xchgl	%eax, (%rdi)	/* NB:	 lock is implied */
@@ -185,7 +185,7 @@ __lll_timedlock_wait:
 
 1:	movl	$SYS_futex, %eax
 	movl	$2, %edx
-	syscall
+	SYSCALL
 
 2:	xchgl	%edx, (%rdi)	/* NB:   lock is implied */
 
@@ -279,7 +279,7 @@ __lll_timedlock_wait:
 	LOAD_FUTEX_WAIT (%esi)
 	movq	%r12, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	/* NB: %edx == 2 */
 	xchgl	%edx, (%r12)
@@ -336,7 +336,7 @@ __lll_unlock_wake_private:
 	LOAD_PRIVATE_FUTEX_WAKE (%esi)
 	movl	$1, %edx	/* Wake one thread.  */
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	popq	%rdx
 	cfi_adjust_cfa_offset(-8)
@@ -366,7 +366,7 @@ __lll_unlock_wake:
 	LOAD_FUTEX_WAKE (%esi)
 	movl	$1, %edx	/* Wake one thread.  */
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	popq	%rdx
 	cfi_adjust_cfa_offset(-8)
@@ -435,7 +435,7 @@ __lll_timedwait_tid:
 #endif
 	movq	%r12, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	cmpl	$0, (%rdi)
 	jne	1f
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
index 5a80ddd..f7319ca 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
@@ -214,7 +214,7 @@ LLL_STUB_UNWIND_INFO_END
     register const struct timespec *__to __asm ("r10") = timeout;	      \
     int __status;							      \
     register __typeof (val) _val __asm ("edx") = (val);			      \
-    __asm __volatile ("syscall"						      \
+    __asm __volatile (SYSCALLDB						      \
 		      : "=a" (__status)					      \
 		      : "0" (SYS_futex), "D" (futex),			      \
 			"S" (__lll_private_flag (FUTEX_WAIT, private)),	      \
@@ -229,7 +229,7 @@ LLL_STUB_UNWIND_INFO_END
     int __ignore;							      \
     register __typeof (nr) _nr __asm ("edx") = (nr);			      \
     LIBC_PROBE (lll_futex_wake, 3, futex, nr, private);                       \
-    __asm __volatile ("syscall"						      \
+    __asm __volatile (SYSCALLDB						      \
 		      : "=a" (__ignore)					      \
 		      : "0" (SYS_futex), "D" (futex),			      \
 			"S" (__lll_private_flag (FUTEX_WAKE, private)),	      \
@@ -532,7 +532,7 @@ LLL_STUB_UNWIND_INFO_END
     {									      \
       int ignore;							      \
       __asm __volatile (LOCK_INSTR "orl %3, (%2)\n\t"			      \
-			"syscall"					      \
+			SYSCALLDB					      \
 			: "=m" (futex), "=a" (ignore)			      \
 			: "D" (&(futex)), "i" (FUTEX_OWNER_DIED),	      \
 			  "S" (__lll_private_flag (FUTEX_WAKE, private)),     \
@@ -547,7 +547,7 @@ LLL_STUB_UNWIND_INFO_END
      register int __nr_move __asm ("r10") = nr_move;			      \
      register void *__mutex __asm ("r8") = mutex;			      \
      register int __val __asm ("r9") = val;				      \
-     __asm __volatile ("syscall"					      \
+     __asm __volatile (SYSCALLDB					      \
 		       : "=a" (__res)					      \
 		       : "0" (__NR_futex), "D" ((void *) ftx),		      \
 			 "S" (__lll_private_flag (FUTEX_CMP_REQUEUE,	      \
@@ -573,7 +573,7 @@ LLL_STUB_UNWIND_INFO_END
     if (_tid != 0)							      \
       __asm __volatile ("xorq %%r10, %%r10\n\t"				      \
 			"1:\tmovq %2, %%rax\n\t"			      \
-			"syscall\n\t"					      \
+			SYSCALLDB					      \
 			"cmpl $0, (%%rdi)\n\t"				      \
 			"jne 1b"					      \
 			: "=&a" (__ignore)				      \
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
index 0b4ef71..36c5572 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
@@ -80,7 +80,7 @@ __lll_robust_lock_wait:
 	jnz	2f
 
 1:	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	movl	(%rdi), %eax
 
@@ -145,7 +145,7 @@ __lll_robust_timedlock_wait:
 	jnz	6f
 
 5:	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	movl	%eax, %ecx
 
 	movl	(%rdi), %eax
@@ -257,7 +257,7 @@ __lll_robust_timedlock_wait:
 	LOAD_FUTEX_WAIT (%esi)
 	movq	%r12, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	movq	%rax, %rcx
 
 	movl	(%r12), %eax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S
index 61c2f54..e70362c 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S
@@ -62,7 +62,7 @@ pthread_barrier_wait:
 #endif
 	xorq	%r10, %r10
 8:	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	/* Don't return on spurious wakeups.  The syscall does not change
 	   any register except %eax so there is no need to reload any of
@@ -109,7 +109,7 @@ pthread_barrier_wait:
 	movl	$FUTEX_WAKE, %esi
 	orl	PRIVATE(%rdi), %esi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	/* Increment LEFT.  If this brings the count back to the
 	   initial count unlock the object.  */
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
index 67ff5fc..a95f808 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
@@ -90,7 +90,7 @@ __pthread_cond_broadcast:
 	movl	$SYS_futex, %eax
 	movl	$1, %edx
 	movl	$0x7fffffff, %r10d
-	syscall
+	SYSCALL
 
 	/* For any kind of error, which mainly is EAGAIN, we try again
 	   with WAKE.  The general test also covers running on old
@@ -106,7 +106,7 @@ __pthread_cond_broadcast:
 	movl	$SYS_futex, %eax
 	movl	$1, %edx
 	movl	$0x7fffffff, %r10d
-	syscall
+	SYSCALL
 
 	/* For any kind of error, which mainly is EAGAIN, we try again
 	   with WAKE.  The general test also covers running on old
@@ -172,7 +172,7 @@ __pthread_cond_broadcast:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	jmp	10b
 	.size	__pthread_cond_broadcast, .-__pthread_cond_broadcast
 versioned_symbol (libpthread, __pthread_cond_broadcast, pthread_cond_broadcast,
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
index 3bff19b..80f4b47 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
@@ -82,7 +82,7 @@ __pthread_cond_signal:
 	addq	$cond_lock, %r8
 #endif
 	movl	$FUTEX_OP_CLEAR_WAKE_IF_GT_ONE, %r9d
-	syscall
+	SYSCALL
 #if cond_lock != 0
 	subq	$cond_lock, %r8
 #endif
@@ -99,7 +99,7 @@ __pthread_cond_signal:
 	movq	%rcx, %r8
 	xorq	%r10, %r10
 	movl	(%rdi), %r9d	// XXX Can this be right?
-	syscall
+	SYSCALL
 
 	leaq	-cond_futex(%rdi), %r8
 
@@ -118,7 +118,7 @@ __pthread_cond_signal:
 	movl	$SYS_futex, %eax
 	/* %rdx should be 1 already from $FUTEX_WAKE_OP syscall.
 	movl	$1, %edx  */
-	syscall
+	SYSCALL
 
 	/* Unlock.  */
 4:	LOCK
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
index 15e451a..14b768a 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
@@ -188,7 +188,7 @@ __pthread_cond_timedwait:
 	movq	%r12, %rdx
 	addq	$cond_futex, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	cmpl	$0, %eax
 	sete	%r15b
@@ -234,7 +234,7 @@ __pthread_cond_timedwait:
 	movq	%r12, %rdx
 	addq	$cond_futex, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 62:	movq	%rax, %r14
 
 	movl	(%rsp), %edi
@@ -321,7 +321,7 @@ __pthread_cond_timedwait:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	subq	$cond_nwaiters, %rdi
 
 55:	LOCK
@@ -485,15 +485,8 @@ __pthread_cond_timedwait:
 	/* Only clocks 0 and 1 are allowed so far.  Both are handled in the
 	   kernel.  */
 	leaq	32(%rsp), %rsi
-#  ifdef SHARED
-	mov	__vdso_clock_gettime@GOTPCREL(%rip), %RAX_LP
-	mov	(%rax), %RAX_LP
-	PTR_DEMANGLE (%RAX_LP)
-	call	*%rax
-#  else
 	movl	$__NR_clock_gettime, %eax
-	syscall
-#  endif
+	SYSCALL
 
 	/* Compute relative timeout.  */
 	movq	(%r13), %rcx
@@ -560,7 +553,7 @@ __pthread_cond_timedwait:
 # endif
 	addq	$cond_futex, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	movq	%rax, %r14
 
 	movl	(%rsp), %edi
@@ -732,7 +725,7 @@ __condvar_cleanup2:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	subq	$cond_nwaiters, %rdi
 	movl	$1, %r12d
 
@@ -769,7 +762,7 @@ __condvar_cleanup2:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	/* Lock the mutex only if we don't own it already.  This only happens
 	   in case of PI mutexes, if we got cancelled after a successful
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
index 2c6b515..296659c 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
@@ -138,7 +138,7 @@ __pthread_cond_wait:
 
 	movl	$(FUTEX_WAIT_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	cmpl	$0, %eax
 	sete	%r8b
@@ -180,7 +180,7 @@ __pthread_cond_wait:
 #endif
 60:	xorb	%r8b, %r8b
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 62:	movl	(%rsp), %edi
 	callq	__pthread_disable_asynccancel
@@ -239,7 +239,7 @@ __pthread_cond_wait:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	subq	$cond_nwaiters, %rdi
 
 17:	LOCK
@@ -455,7 +455,7 @@ __condvar_cleanup1:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	subq	$cond_nwaiters, %rdi
 	movl	$1, %ecx
 
@@ -493,7 +493,7 @@ __condvar_cleanup1:
 	orl	$FUTEX_WAKE, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	/* Lock the mutex only if we don't own it already.  This only happens
 	   in case of PI mutexes, if we got cancelled after a successful
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
index 7f5c081..38ecb12 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
@@ -90,7 +90,7 @@ __pthread_once:
 # endif
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	jmp	6b
 
 	/* Preserve the pointer to the control variable.  */
@@ -123,7 +123,7 @@ __pthread_once:
 	orl	%fs:PRIVATE_FUTEX, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 4:	addq	$8, %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -152,7 +152,7 @@ clear_once_control:
 	orl	%fs:PRIVATE_FUTEX, %esi
 #endif
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	movq	%r8, %rdi
 .LcallUR:
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S
index 264ba58..c54f316 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S
@@ -82,7 +82,7 @@ __pthread_rwlock_rdlock:
 #endif
 	addq	$READERS_WAKEUP, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	subq	$READERS_WAKEUP, %rdi
 
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
index f60530e..fb7894a 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
@@ -109,7 +109,7 @@ pthread_rwlock_timedrdlock:
 #endif
 21:	leaq	READERS_WAKEUP(%r12), %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	movq	%rax, %rdx
 
 #ifndef __ASSUME_FUTEX_CLOCK_REALTIME
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
index 7870733..f9eee96 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
@@ -107,7 +107,7 @@ pthread_rwlock_timedwrlock:
 #endif
 21:	leaq	WRITERS_WAKEUP(%r12), %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 	movq	%rax, %rdx
 
 #ifndef __ASSUME_FUTEX_CLOCK_REALTIME
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S
index e971529..bdd1f4d 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S
@@ -79,7 +79,7 @@ __pthread_rwlock_unlock:
 #endif
 	movl	$SYS_futex, %eax
 	movq	%r10, %rdi
-	syscall
+	SYSCALL
 
 	xorl	%eax, %eax
 	retq
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S
index ff5392c..1afe769 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S
@@ -80,7 +80,7 @@ __pthread_rwlock_wrlock:
 #endif
 	addq	$WRITERS_WAKEUP, %rdi
 	movl	$SYS_futex, %eax
-	syscall
+	SYSCALL
 
 	subq	$WRITERS_WAKEUP, %rdi
 
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
index 65e715d..7152395 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
@@ -52,7 +52,7 @@ sem_post:
 	movl	$FUTEX_WAKE, %esi
 	orl	PRIVATE(%rdi), %esi
 	movl	$1, %edx
-	syscall
+	SYSCALL
 
 	testq	%rax, %rax
 	js	1f
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
index acb79db..f9db4d1 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
@@ -97,7 +97,7 @@ sem_timedwait:
 	orl	PRIVATE(%rdi), %esi
 	movl	$SYS_futex, %eax
 	xorl	%edx, %edx
-	syscall
+	SYSCALL
 	movq	%rax, %r9
 #if VALUE != 0
 	leaq	-VALUE(%rdi), %rdi
@@ -233,7 +233,7 @@ sem_timedwait:
 # endif
 	movl	$SYS_futex, %eax
 	xorl	%edx, %edx
-	syscall
+	SYSCALL
 	movq	%rax, %r14
 
 	movl	16(%rsp), %edi
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
index 7f91148..ac4b8e8 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
@@ -81,7 +81,7 @@ sem_wait:
 	orl	PRIVATE(%rdi), %esi
 #endif
 	xorl	%edx, %edx
-	syscall
+	SYSCALL
 	movq	%rax, %rcx
 
 	xchgq	%r8, %rdi
diff --git a/nptl/sysdeps/x86_64/pthreaddef.h b/nptl/sysdeps/x86_64/pthreaddef.h
index 50587b8..374b553 100644
--- a/nptl/sysdeps/x86_64/pthreaddef.h
+++ b/nptl/sysdeps/x86_64/pthreaddef.h
@@ -48,4 +48,5 @@
 
 /* While there is no such syscall.  */
 #define __exit_thread_inline(val) \
-  asm volatile ("syscall" :: "a" (__NR_exit), "D" (val))
+  asm volatile ("pushq %%rbx\n\tmovq syscalldb@GOTPCREL(%%rip), %%rbx\n\t" \
+		"call %%rbx\n\t" :: "a" (__NR_exit), "D" (val) : "bx" )
diff --git a/nptl/sysdeps/x86_64/tls.h b/nptl/sysdeps/x86_64/tls.h
index f3b7649..433b8c9 100644
--- a/nptl/sysdeps/x86_64/tls.h
+++ b/nptl/sysdeps/x86_64/tls.h
@@ -28,6 +28,7 @@
 # include <sysdep.h>
 # include <libc-internal.h>
 # include <kernel-features.h>
+# include <shim_tls.h>
 
 /* Replacement type for __m128 since this file is included by ld.so,
    which is compiled with -mno-sse.  It must not change the alignment
@@ -67,6 +68,10 @@ typedef struct
 # else
   int __unused1;
 # endif
+
+  shim_tcb_t shim_tcb;	/* For graphene, we allocate a shim_tcb
+			   in the real tcb. */
+
   int rtld_must_xmm_save;
   /* Reservation of some values for the TM ABI.  */
   void *__private_tm[5];
@@ -135,6 +140,12 @@ typedef struct
 # define GET_DTV(descr) \
   (((tcbhead_t *) (descr))->dtv)
 
+/* For Graphene */
+#define SYSCALLDB							      \
+	"pushq %%rbx\n\t"						      \
+	"movq syscalldb@GOTPCREL(%%rip), %%rbx\n\t"			      \
+	"callq *%%rbx\n\t"						      \
+	"popq %%rbx\n\t"
 
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
@@ -152,7 +163,7 @@ typedef struct
      _head->self = _thrdescr;						      \
 									      \
      /* It is a simple syscall to set the %fs value for the thread.  */	      \
-     asm volatile ("syscall"						      \
+     asm volatile (SYSCALLDB						      \
 		   : "=a" (_result)					      \
 		   : "0" ((unsigned long int) __NR_arch_prctl),		      \
 		     "D" ((unsigned long int) ARCH_SET_FS),		      \
diff --git a/scripts/mkinstalldirs b/scripts/mkinstalldirs
index f945dbf..3c0e48c 100755
--- a/scripts/mkinstalldirs
+++ b/scripts/mkinstalldirs
@@ -20,9 +20,9 @@ do
      esac
 
      if test ! -d "$pathcomp"; then
-        echo "mkdir $pathcomp" 1>&2
+        echo "mkdir -p $pathcomp" 1>&2
 
-        mkdir "$pathcomp" || lasterr=$?
+        mkdir -p "$pathcomp" || lasterr=$?
 
         if test ! -d "$pathcomp"; then
   	  errstatus=$lasterr
diff --git a/shlib-versions b/shlib-versions
index 9344590..4edb370 100644
--- a/shlib-versions
+++ b/shlib-versions
@@ -107,3 +107,5 @@ sparc64.*-.*-.*		libBrokenLocale=1	GLIBC_2.2
 # This defines the libgcc soname version this glibc is to load for
 # asynchronous cancellation to work correctly.
 .*-.*-.*		libgcc_s=1
+
+.*-.*-.*		liblibos=1
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index c667e34..9803b8a 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -854,8 +854,7 @@ extern void _dl_sort_fini (struct link_map **maps, size_t nmaps, char *used,
    any shared object mappings.  The `r_state' member of `struct r_debug'
    says what change is taking place.  This function's address is
    the value of the `r_brk' member.  */
-extern void _dl_debug_state (void);
-rtld_hidden_proto (_dl_debug_state)
+extern void __libc_dl_debug_state (void) __attribute__((weak));
 
 /* Initialize `struct r_debug' if it has not already been done.  The
    argument is the run-time load address of the dynamic linker, to be put
diff --git a/sysdeps/unix/sysv/linux/_exit.c b/sysdeps/unix/sysv/linux/_exit.c
index 18c4fce..a21fb32 100644
--- a/sysdeps/unix/sysv/linux/_exit.c
+++ b/sysdeps/unix/sysv/linux/_exit.c
@@ -29,9 +29,9 @@ _exit (status)
   while (1)
     {
 #ifdef __NR_exit_group
-      INLINE_SYSCALL (exit_group, 1, status);
+      INLINE_SYSCALL_ASM (exit_group, 1, status);
 #endif
-      INLINE_SYSCALL (exit, 1, status);
+      INLINE_SYSCALL_ASM (exit, 1, status);
 
 #ifdef ABORT_INSTRUCTION
       ABORT_INSTRUCTION;
diff --git a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
index d9bdb67..9719699 100644
--- a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
+++ b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
@@ -84,7 +84,8 @@ ENTRY(____longjmp_chk)
 	xorl	%edi, %edi
 	lea	-sizeSS(%rsp), %RSI_LP
 	movl	$__NR_sigaltstack, %eax
-	syscall
+	SYSCALL
+
 	/* Without working sigaltstack we cannot perform the test.  */
 	testl	%eax, %eax
 	jne	.Lok2
diff --git a/sysdeps/unix/sysv/linux/x86_64/clock_gettime.c b/sysdeps/unix/sysv/linux/x86_64/clock_gettime.c
index f712110..f6bad14 100644
--- a/sysdeps/unix/sysv/linux/x86_64/clock_gettime.c
+++ b/sysdeps/unix/sysv/linux/x86_64/clock_gettime.c
@@ -1,5 +1,6 @@
 #include "bits/libc-vdso.h"
 
+#if 0 /* in Graphene, disallow VDSO calls */
 #ifdef SHARED
 # define SYSCALL_GETTIME(id, tp) \
   ({ long int (*f) (clockid_t, struct timespec *) = __vdso_clock_gettime; \
@@ -16,5 +17,6 @@
   PTR_DEMANGLE (f);							  \
   f (id, tp); })
 #endif
+#endif
 
 #include "../clock_gettime.c"
diff --git a/sysdeps/unix/sysv/linux/x86_64/clone.S b/sysdeps/unix/sysv/linux/x86_64/clone.S
index 53f9fbd..80d28b5 100644
--- a/sysdeps/unix/sysv/linux/x86_64/clone.S
+++ b/sysdeps/unix/sysv/linux/x86_64/clone.S
@@ -61,11 +61,15 @@ ENTRY (BP_SYM (__clone))
 	jz	SYSCALL_ERROR_LABEL
 
 	/* Insert the argument onto the new stack.  */
-	subq	$16,%rsi
-	movq	%rcx,8(%rsi)
+	subq	$24,%rsi
+	movq	%rcx,16(%rsi)
 
 	/* Save the function pointer.  It will be popped off in the
 	   child in the ebx frobbing below.  */
+	movq	%rdi,8(%rsi)
+
+	/* Push an additional pointer as return address into the stack */
+	leaq	L(clone_return)(%rip),%rdi
 	movq	%rdi,0(%rsi)
 
 	/* Do the system call.  */
@@ -78,8 +82,9 @@ ENTRY (BP_SYM (__clone))
 	/* End FDE now, because in the child the unwind info will be
 	   wrong.  */
 	cfi_endproc;
-	syscall
+	SYSCALL
 
+L(clone_return):
 	testq	%rax,%rax
 	jl	SYSCALL_ERROR_LABEL
 	jz	L(thread_start)
@@ -101,13 +106,14 @@ L(thread_start):
 	movl	$-1, %eax
 	jne	2f
 	movl	$SYS_ify(getpid), %eax
-	syscall
+	SYSCALL
 2:	movl	%eax, %fs:PID
 	movl	%eax, %fs:TID
 1:
 #endif
 
 	/* Set up arguments for the function call.  */
+	addq	$8,%rsp		/* Skip the return address */
 	popq	%rax		/* Function to call.  */
 	popq	%rdi		/* Argument.  */
 	call	*%rax
diff --git a/sysdeps/unix/sysv/linux/x86_64/getcontext.S b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
index 5f2b64c..df57736 100644
--- a/sysdeps/unix/sysv/linux/x86_64/getcontext.S
+++ b/sysdeps/unix/sysv/linux/x86_64/getcontext.S
@@ -75,7 +75,7 @@ ENTRY(__getcontext)
 #endif
 	movl	$_NSIG8,%r10d
 	movl	$__NR_rt_sigprocmask, %eax
-	syscall
+	SYSCALL
 	cmpq	$-4095, %rax		/* Check %rax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c b/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
index d52f938..d75b502 100644
--- a/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
+++ b/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
@@ -17,6 +17,7 @@
 
 #include <sys/time.h>
 
+#if 0 /* In graphene, do not use vsyscall or VDSO call */
 #ifdef SHARED
 
 # include <dl-vdso.h>
@@ -42,7 +43,8 @@ asm (".type __gettimeofday, %gnu_indirect_function");
 asm (".globl __GI___gettimeofday\n"
      "__GI___gettimeofday = __gettimeofday");
 
-#else
+#endif
+#endif
 
 # include <sysdep.h>
 # include <errno.h>
@@ -54,6 +56,5 @@ __gettimeofday (struct timeval *tv, struct timezone *tz)
 }
 libc_hidden_def (__gettimeofday)
 
-#endif
 weak_alias (__gettimeofday, gettimeofday)
 libc_hidden_weak (gettimeofday)
diff --git a/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S b/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
index 3b319d7..98d8612 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
+++ b/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
@@ -30,6 +30,7 @@ ENTRY (sched_getcpu)
 	sub	$0x8, %rsp
 	cfi_adjust_cfa_offset(8)
 
+#if 0 /* for Graphene, never do VDSO calls */
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
 	movl	$VGETCPU_CACHE_OFFSET, %edx
@@ -39,16 +40,19 @@ ENTRY (sched_getcpu)
 	movq	__vdso_getcpu(%rip), %rax
 	PTR_DEMANGLE (%rax)
 	callq	*%rax
-#else
-# ifdef __NR_getcpu
+#endif
+#endif
+
+#ifdef __NR_getcpu
 	movl	$__NR_getcpu, %eax
-	syscall
-#  ifndef __ASSUME_GETCPU_SYSCALL
+	SYSCALL
+#endif
+
+#if 0 /* for Graphene, never do vsyscall */
+# ifndef __ASSUME_GETCPU_SYSCALL
 	cmpq	$-ENOSYS, %rax
 	jne	1f
-#  endif
-# endif
-# ifndef __ASSUME_GETCPU_SYSCALL
+
 	movq	$VSYSCALL_ADDR_vgetcpu, %rax
 	callq	*%rax
 1:
diff --git a/sysdeps/unix/sysv/linux/x86_64/setcontext.S b/sysdeps/unix/sysv/linux/x86_64/setcontext.S
index adcb243..0d662e3 100644
--- a/sysdeps/unix/sysv/linux/x86_64/setcontext.S
+++ b/sysdeps/unix/sysv/linux/x86_64/setcontext.S
@@ -43,7 +43,7 @@ ENTRY(__setcontext)
 	movl	$SIG_SETMASK, %edi
 	movl	$_NSIG8,%r10d
 	movl	$__NR_rt_sigprocmask, %eax
-	syscall
+	SYSCALL
 	popq	%rdi			/* Reload %rdi, adjust stack.  */
 	cfi_adjust_cfa_offset(-8)
 	cmpq	$-4095, %rax		/* Check %rax for error.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigaction.c b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
index 5a3ad18..9ac8b6e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sigaction.c
+++ b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
@@ -129,7 +129,8 @@ asm									\
    "	.type __" #name ",@function\n"					\
    "__" #name ":\n"							\
    "	movq $" #syscall ", %rax\n"					\
-   "	syscall\n"							\
+   "	movq syscalldb@GOTPCREL(%rip), %rbx\n"				\
+   "	call *%rbx\n"							\
    ".LEND_" #name ":\n"							\
    ".section .eh_frame,\"a\",@progbits\n"				\
    ".LSTARTFRAME_" #name ":\n"						\
diff --git a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
index 0d04a01..e8483db 100644
--- a/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
+++ b/sysdeps/unix/sysv/linux/x86_64/swapcontext.S
@@ -75,7 +75,7 @@ ENTRY(__swapcontext)
 	movl	$SIG_SETMASK, %edi
 	movl	$_NSIG8,%r10d
 	movl	$__NR_rt_sigprocmask, %eax
-	syscall
+	SYSCALL
 	cmpq	$-4095, %rax		/* Check %rax for error.  */
 	jae	SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/syscall.S b/sysdeps/unix/sysv/linux/x86_64/syscall.S
index 87dfd8c..c144b42 100644
--- a/sysdeps/unix/sysv/linux/x86_64/syscall.S
+++ b/sysdeps/unix/sysv/linux/x86_64/syscall.S
@@ -34,7 +34,7 @@ ENTRY (syscall)
 	movq %r8, %r10
 	movq %r9, %r8
 	movq 8(%rsp),%r9	/* arg6 is on the stack.  */
-	syscall			/* Do the system call.  */
+	SYSCALL			/* Do the system call.  */
 	cmpq $-4095, %rax	/* Check %rax for error.  */
 	jae SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
 	ret			/* Return to caller.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index 5323104..d466181 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -23,6 +23,7 @@
 #include <bp-sym.h>
 #include <bp-asm.h>
 #include <tls.h>
+#include "syscalldb.h"
 
 #ifdef IS_IN_rtld
 # include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
@@ -174,11 +175,18 @@
 
     Syscalls of more than 6 arguments are not supported.  */
 
+# undef	SYSCALL
+# define SYSCALL				\
+    pushq %rbx;					\
+    movq syscalldb@GOTPCREL(%rip), %rbx;	\
+    call *%rbx;					\
+    popq %rbx;
+
 # undef	DO_CALL
 # define DO_CALL(syscall_name, args)		\
     DOARGS_##args				\
     movl $SYS_ify (syscall_name), %eax;		\
-    syscall;
+    SYSCALL
 
 # define DOARGS_0 /* nothing */
 # define DOARGS_1 /* nothing */
@@ -192,9 +200,20 @@
 /* Define a macro which expands inline into the wrapper code for a system
    call.  */
 # undef INLINE_SYSCALL
-# define INLINE_SYSCALL(name, nr, args...) \
+# define INLINE_SYSCALL(name, nr_args...) \
+  ({									      \
+    unsigned long int resultvar = INTERNAL_SYSCALL (name, , ##nr_args);	      \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
+      {									      \
+	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
+	resultvar = (unsigned long int) -1;				      \
+      }									      \
+    (long int) resultvar; })
+
+# undef INLINE_SYSCALL_ASM
+# define INLINE_SYSCALL_ASM(name, nr_args...) \
   ({									      \
-    unsigned long int resultvar = INTERNAL_SYSCALL (name, , nr, args);	      \
+    unsigned long int resultvar = INTERNAL_SYSCALL_ASM (name, , ##nr_args);   \
     if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
       {									      \
 	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
@@ -206,9 +225,9 @@
    into the wrapper code for a system call.  It should be used when size
    of any argument > size of long int.  */
 # undef INLINE_SYSCALL_TYPES
-# define INLINE_SYSCALL_TYPES(name, nr, args...) \
+# define INLINE_SYSCALL_TYPES(name, nr_args...) \
   ({									      \
-    unsigned long int resultvar = INTERNAL_SYSCALL_TYPES (name, , nr, args);  \
+    unsigned long int resultvar = INTERNAL_SYSCALL_TYPES (name, , ##nr_args); \
     if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
       {									      \
 	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
@@ -225,13 +244,20 @@
     LOAD_ARGS_##nr (args)						      \
     LOAD_REGS_##nr							      \
     asm volatile (							      \
-    "syscall\n\t"							      \
+    "movq syscalldb@GOTPCREL(%%rip), %%rbx\n\t"				      \
+    "call *%%rbx\n\t"							      \
     : "=a" (resultvar)							      \
-    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");		      \
+    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx", "bx");	      \
     (long int) resultvar; })
+# define INTERNAL_SYSCALL_NCS_ASM INTERNAL_SYSCALL_NCS
+
 # undef INTERNAL_SYSCALL
-# define INTERNAL_SYSCALL(name, err, nr, args...) \
-  INTERNAL_SYSCALL_NCS (__NR_##name, err, nr, ##args)
+# define INTERNAL_SYSCALL(name, err, nr_args...) \
+  INTERNAL_SYSCALL_NCS (__NR_##name, err, ##nr_args)
+
+# undef INTERNAL_SYSCALL_ASM
+# define INTERNAL_SYSCALL_ASM(name, err, nr_args...) \
+  INTERNAL_SYSCALL_NCS_ASM (__NR_##name, err, ##nr_args)
 
 # define INTERNAL_SYSCALL_NCS_TYPES(name, err, nr, args...) \
   ({									      \
@@ -239,9 +265,10 @@
     LOAD_ARGS_TYPES_##nr (args)						      \
     LOAD_REGS_TYPES_##nr (args)						      \
     asm volatile (							      \
-    "syscall\n\t"							      \
+    "movq syscalldb@GOTPCREL(%%rip), %%rbx\n\t"				      \
+    "call *%%rbx\n\t"							      \
     : "=a" (resultvar)							      \
-    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");		      \
+    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx", "bx");	      \
     (long int) resultvar; })
 # undef INTERNAL_SYSCALL_TYPES
 # define INTERNAL_SYSCALL_TYPES(name, err, nr, args...) \
@@ -254,6 +281,7 @@
 # undef INTERNAL_SYSCALL_ERRNO
 # define INTERNAL_SYSCALL_ERRNO(val, err)	(-(val))
 
+# if 0 /* for Graphene, never do vsyscall */
 # ifdef SHARED
 #  define INLINE_VSYSCALL(name, nr, args...) \
   ({									      \
@@ -302,12 +330,13 @@
     v_ret;								      \
   })
 
-# else
-#  define INLINE_VSYSCALL(name, nr, args...) \
-  INLINE_SYSCALL (name, nr, ##args)
-#  define INTERNAL_VSYSCALL(name, err, nr, args...) \
-  INTERNAL_SYSCALL (name, err, nr, ##args)
 # endif
+# endif
+
+#  define INLINE_VSYSCALL(name, nr_args...) \
+  INLINE_SYSCALL (name, ##nr_args)
+#  define INTERNAL_VSYSCALL(name, err, nr_args...) \
+  INTERNAL_SYSCALL (name, err, ##nr_args)
 
 # define LOAD_ARGS_0()
 # define LOAD_REGS_0
diff --git a/sysdeps/unix/sysv/linux/x86_64/time.c b/sysdeps/unix/sysv/linux/x86_64/time.c
deleted file mode 100644
index 65703ca..0000000
--- a/sysdeps/unix/sysv/linux/x86_64/time.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* Copyright (C) 2001,02,2003,2011 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifdef SHARED
-/* Redefine time so that the compiler won't complain about the type
-   mismatch with the IFUNC selector in strong_alias, below.  */
-#undef time
-#define time __redirect_time
-#include <time.h>
-
-#include <dl-vdso.h>
-
-#define VSYSCALL_ADDR_vtime	0xffffffffff600400
-
-/* Avoid DWARF definition DIE on ifunc symbol so that GDB can handle
-   ifunc symbol properly.  */
-extern __typeof (__redirect_time) __libc_time;
-void *time_ifunc (void) __asm__ ("__libc_time");
-
-void *
-time_ifunc (void)
-{
-  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
-
-  /* If the vDSO is not available we fall back on the old vsyscall.  */
-  return _dl_vdso_vsym ("__vdso_time", &linux26) ?: (void *) VSYSCALL_ADDR_vtime;
-}
-__asm (".type __libc_time, %gnu_indirect_function");
-
-#undef time
-strong_alias (__libc_time, time)
-libc_hidden_ver (__libc_time, time)
-
-#else
-
-# include <time.h>
-# include <sysdep.h>
-
-time_t
-time (time_t *t)
-{
-  INTERNAL_SYSCALL_DECL (err);
-  return INTERNAL_SYSCALL (time, err, 1, t);
-}
-
-#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/vfork.S b/sysdeps/unix/sysv/linux/x86_64/vfork.S
index c28087d..ea4ff9f 100644
--- a/sysdeps/unix/sysv/linux/x86_64/vfork.S
+++ b/sysdeps/unix/sysv/linux/x86_64/vfork.S
@@ -38,7 +38,7 @@ ENTRY (__vfork)
 
 	/* Stuff the syscall number in RAX and enter into the kernel.  */
 	movl	$SYS_ify (vfork), %eax
-	syscall
+	SYSCALL
 
 	/* Push back the return PC.  */
 	pushq	%rdi
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index d2654aa..9bd840f 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -511,7 +511,8 @@ elf_machine_lazy_rel (struct link_map *map,
 	value = ((ElfW(Addr) (*) (void)) value) ();
       *reloc_addr = value;
     }
-  else
+  /* for graphene, get around R_X86_64_NONE */
+  else if (__builtin_expect (r_type != R_X86_64_NONE, 1))
     _dl_reloc_bad_type (map, r_type, 1);
 }
 
