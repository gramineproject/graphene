# KEEP THIS FILE SORTED
# in case of trouble, use ./contrib/conf_lint.py < FILENAME

# Common problems:
# - no FUNC() - feature (typically, a syscall) not implemented
# - utimensat - tries to call utimensat() as part of setup, fails
# - tmpfs - tries to mount tmpfs
# - copy child - tries to copy a child binary (X_child) to "."
# - kernel config - tries to read kernel .config

[DEFAULT]
timeout = 30

# no setsockopt(SOL_IP)
[accept02]
skip = yes

# utimensat
[access01]
skip = yes

# utimensat
[access02]
skip = yes

# tmpfs
[access04]
skip = yes

# tmpfs
[acct01]
skip = yes

# kernel config
[acct02]
skip = yes

# no add_key()
[add_key*]
skip = yes

# no adjtimex()
[adjtimex*]
skip = yes

# getgrgid(user GID) fails with ENOENT
[bind02]
skip = yes

# aborts in getsockname() -> inet_copy_addr() on AF_UNIX
[bind04]
skip = yes

# aborts in getsockname() -> inet_copy_addr() on AF_UNIX
[bind05]
skip = yes

# kernel config
[bind06]
skip = yes

# no BPF
[bpf_map*]
skip = yes

# no BPF
[bpf_prog*]
skip = yes

# no cacheflush()
[cacheflush*]
skip = yes

# no capget()
[capget*]
skip = yes

# no capset()
[capset*]
skip = yes

# tries to mount a filesystem
[chdir01]
skip = yes

# symlink test
[chdir01A]
skip = yes

# symlink test
[chmod01A]
skip = yes

[chmod02]
timeout = 40

# getgrnam("bin") fails with ENOENT
[chmod05]
skip = yes

# tmpfs
[chmod06]
skip = yes

# getgrnam("users") fails with ENOENT
[chmod07]
skip = yes

# chown() does nothing
[chown*]
skip = yes

# no seteuid()
[chroot01]
skip = yes

# no symlink()
[chroot03]
skip = yes

# hangs, no setuid(), rmdir() failing
[chroot04]
skip = yes

# no adjtime()
[clock_adjtime*]
skip = yes

# kernel config
[clock_gettime03]
skip = yes

# 4. after SIGINT, remaining time > requested time
[clock_nanosleep01]
timeout = 40
must-pass =
    1
    2
    3

# kernel config
[clock_nanosleep03]
skip = yes

# clock_nanosleep not supported with non-zero flags (CLOCK_MONOTONIC, CLOCK_REALTIME), fails with EINVAL
[clock_nanosleep04]
skip = yes

# no clock_settime()
[clock_settime*]
skip = yes

# Invokes clone() with CLONE_VM but without either of CLONE_THREAD or CLONE_VFORK, i.e., a process
# sharing its parents address space. Graphene doesn't support this exotic model. Bug exposed by
# https://github.com/oscarlab/graphene/pull/1034.
[clone02]
skip = yes

[clone03]
timeout = 40

# CLONE_VFORK implemented only as an alias to fork()
[clone05]
skip = yes

[clone06]
timeout = 40

# no CLONE_PARENT
[clone08]
skip = yes

# no CLONE_NEWNET
[clone09]
skip = yes

# no clone3()
[clone3*]
skip = yes

# opens /proc/sys/kernel/tainted
[connect02]
skip = yes

# no copy_file_range()
[copy_file_range*]
skip = yes

# no seteuid()
[creat04]
skip = yes

# tmpfs
[creat06]
skip = yes

# copy child
[creat07]
skip = yes

# getgrnam("nobody") and getgrnam("nogroup") fails with ENOENT
[creat08]
skip = yes

# no delete_module()
[delete_module*]
skip = yes

[dirtyc0w]
skip = yes

# Subtest 4 tries to unlink a file which is not readable. See
# https://github.com/oscarlab/graphene/issues/1248.
[dup07]
must-pass =
    1
    2
    3

# Subtest 4 tries to unlink a file which is not readable. See
# https://github.com/oscarlab/graphene/issues/1248.
[dup202]
must-pass =
    1
    2
    3

# complex test, not all of its checking is implemented in Graphene
[epoll01]
skip = yes

# segfault: uses sigprocmask and sends signals, broken in Graphene
[epoll_pwait01]
skip = yes

# test requires libaio
[eventfd01]
skip = yes

# eventfd not allowed in manifest
[eventfd2_*]
skip = yes

# BROK: Test haven't reported results
[execl01]
must-pass =
    1

# error while loading libc.so.6
[execle01]
skip = yes

# BROK: Test haven't reported results
[execlp01]
must-pass =
    1

# BROK: Test haven't reported results
[execv01]
must-pass =
    1

# error while loading libc.so.6
[execve01]
skip = yes

# copy child
[execve02]
skip = yes

# copy child
[execve04]
skip = yes

# copy child
[execve05]
skip = yes

# copy child
[execveat01]
skip = yes

# copy child
[execveat02]
skip = yes

# copy child
[execveat03]
skip = yes

# BROK: Test haven't reported results
[execvp01]
must-pass =
    1

[faccessat01]
timeout = 80

# no fallocate()
[fallocate*]
skip = yes

# no fanotify()
[fanotify*]
skip = yes

[fchdir02]
timeout = 40

# no seteuid()
[fchdir03]
skip = yes

# getgrnam("users") / "daemon" fails with ENOENT
[fchmod02]
skip = yes

# no seteuid()
[fchmod03]
skip = yes

# no seteuid()
[fchmod04]
skip = yes

# no seteuid(), setegid()
[fchmod05]
skip = yes

# tmpfs
[fchmod06]
skip = yes

[fchmodat01]
timeout = 40

# fchown* does nothing
[fchown*]
skip = yes

[fcntl02_64]
timeout = 40

# no F_GETLK
[fcntl05]
skip = yes

# no F_GETLK
[fcntl05_64]
skip = yes

# no LINUX_LOCK_FILE_REGION support (F_RGETLK/F_RSETLK)
[fcntl06]
skip = yes

[fcntl06_64]
skip = yes

# exec on self fails
[fcntl07]
skip = yes

# exec on self fails
[fcntl07_64]
skip = yes

# no F_SETLK
[fcntl09]
skip = yes

# no F_SETLK
[fcntl09_64]
skip = yes

# no F_SETLKW
[fcntl10]
skip = yes

# no F_SETLKW
[fcntl10_64]
skip = yes

# no locking
[fcntl11]
skip = yes

# no locking
[fcntl11_64]
skip = yes

# 1, 2, 3, 4, 5: tries 99999, F_SETLK*, F_GETLK*, gets ENOSYS instead of EINVAL/EFAULT
[fcntl13]
must-pass =
    6

[fcntl13_64]
timeout = 40
must-pass =
    6

# no statfs()
[fcntl14]
skip = yes

[fcntl14_64]
skip = yes

# no locks
[fcntl15]
skip = yes

[fcntl15_64]
skip = yes

# no statfs
[fcntl16]
skip = yes

[fcntl16_64]
skip = yes

# no locks
[fcntl17]
skip = yes

[fcntl17_64]
skip = yes

# no locks
[fcntl18]
skip = yes

[fcntl18_64]
skip = yes

# no locks
[fcntl19]
skip = yes

[fcntl19_64]
skip = yes

# no locks
[fcntl20]
skip = yes

[fcntl20_64]
skip = yes

# no locks
[fcntl21]
skip = yes

[fcntl21_64]
skip = yes

# no locks
[fcntl22]
skip = yes

[fcntl22_64]
skip = yes

# no statfs()
[fcntl23]
skip = yes

[fcntl23_64]
skip = yes

# no statfs()
[fcntl24]
skip = yes

[fcntl24_64]
skip = yes

# no statfs()
[fcntl25]
skip = yes

[fcntl25_64]
skip = yes

# no statfs()
[fcntl26]
skip = yes

[fcntl26_64]
skip = yes

# 2. unlink in /tmp fails with EACCES
[fcntl28]
must-pass =
    1

[fcntl28_64]
must-pass =
    1

# no F_GETPIPE_SZ
[fcntl30]
skip = yes

[fcntl30_64]
skip = yes

# no F_GETOWN
[fcntl31]
skip = yes

[fcntl31_64]
skip = yes

# no statfs()
[fcntl32]
skip = yes

[fcntl32_64]
skip = yes

# opens /proc/sys/fs/lease-break-time
[fcntl33]
skip = yes

[fcntl33_64]
skip = yes

# kernel 3.15.0 or newer
[fcntl34]
skip = yes

[fcntl34_64]
skip = yes

# opens /proc/sys/fs/pipe-max-size
[fcntl35]
skip = yes

[fcntl35_64]
skip = yes

# kernel 3.15 or newer
[fcntl36]
skip = yes

[fcntl36_64]
skip = yes

# no F_GETPIPE_SZ
[fcntl37]
skip = yes

[fcntl37_64]
skip = yes

# no F_SETSIG
[fcntl38]
skip = yes

[fcntl38_64]
skip = yes

# 2. fdatasync() on /dev/null passes instead of failing with EINVAL
[fdatasync02]
must-pass =
    1

# tries to mount a device
[fdatasync03]
skip = yes

# no fgetxattr(), tries to use mounts and utimensat
[fgetxattr*]
skip = yes

# no flistxattr()
[flistxattr*]
skip = yes

# no flock()
[flock*]
skip = yes

# %fs test, i386 only
[fork05]
skip = yes

# sometimes fails with "x/100 children didn't read correctly from an inheritted fd"
[fork07]
skip = yes

# expect fd to share file offset in parent and child (unsupported)
[fork10]
skip = yes

# opens /proc/sys/kernel/pid_max
[fork13]
skip = yes

# tries to overflow address space
[fork14]
skip = yes

# no fremovexattr()
[fremovexattr*]
skip = yes

# mounts a filesystem
[fsconfig*]
skip = yes

# no fsetxattr()
[fsetxattr*]
skip = yes

# mounts a filesystem
[fsmount*]
skip = yes

# mounts a filesystem
[fsopen*]
skip = yes

# mounts a filesystem
[fspick*]
skip = yes

# creates a file with 0644, but fstat() returns 0600
[fstat02]
skip = yes

[fstat02_64]
skip = yes

# TBROK: Test 0 haven't reported results
[fstat03]
skip = yes

[fstat03_64]
skip = yes

# no fstatfs()
[fstatfs*]
skip = yes

# tries to mount a filesystem
[fsync01]
skip = yes

# no tstatfs()
[fsync02]
skip = yes

# 1. fsync() on a pipe returns EROFS, not EINVAL
# 2. fsync() on a socket returns EROFS, not EINVAL
# 5. fsync() on a fifo returns EROFS, not EINVAL
[fsync03]
timeout = 40
must-pass =
    3
    4

# tries to mount a filesystem
[fsync04]
skip = yes

# no statfs()
[ftruncate04]
skip = yes

[ftruncate04_64]
skip = yes

# opens /proc/PID/stat
[futex_cmp_requeue01]
skip = yes

# always fails to open /proc/PID/stat, but the whole test fails only sometimes
[futex_wait02]
skip = yes

# flaky, see https://github.com/oscarlab/graphene/pull/180#issuecomment-368970338.
[futex_wait03]
skip = yes

# opens /proc/2/task
[futex_wake02]
skip = yes

# no shm_open()
[futex_wake03]
skip = yes

# opens /sys/kernel/mm/hugepages
[futex_wake04]
skip = yes

# no futimesat()
[futimesat*]
skip = yes

# no get_mempolicy()
[get_mempolicy*]
skip = yes

# opens /proc/sys/kernel/pid_max
[get_robust_list01]
skip = yes

# getcpu() always returns cpu0
[getcpu01]
skip = yes

# no symlink()
[getcwd03]
skip = yes

# utimensat
[getcwd04]
must-pass =
    2

# no symlink()
[getdents01]
skip = yes

[getdents01_64]
skip = yes

# tries to open /etc/hosts
[getdtablesize01]
must-pass =
    1

# no 16-bit getegid()
[getegid*_16]
skip = yes

# no 16-bit geteuid()
[geteuid*_16]
skip = yes

# no 16-bit getgid()
[getgid*_16]
skip = yes

# no 16-bit getgroups()
[getgroups*_16]
skip = yes

# tries to execute shell using system()
[gethostid01]
skip = yes

# only ITIMER_REAL is supported
[getitimer01]
skip = yes

# only ITIMER_REAL is supported
[getitimer03]
skip = yes

# 3, 4. getpgid(getppid()) -> getpgid(1) fails with ESRCH
# 5, 6. getpgid(getpgid(0)) -> getpgid(1) fails with ESRCH
# 7. getpgid(1) fails with ESRCH
[getpgid01]
must-pass =
    1
    2

# opens /proc/sys/kernel/pid_max
[getpgid02]
skip = yes

# getpriority() has a dummy implementation that always returns the same value
[getpriority02]
skip = yes

# no getresgid()
[getresgid*]
skip = yes

# no getresuid()
[getresuid*]
skip = yes

# no getrusage()
[getrusage*]
skip = yes

# session management not supported
[getsid01]
skip = yes

# opens /proc/sys/kernel/pid_max
[getsid02]
skip = yes

# Requires support for getsockopt(level=SOL_SOCKET, optname=SO_PEERCRED, ...)
[getsockopt02]
skip = yes

# no 16-bit getuid()
[getuid*_16]
skip = yes

# no getxattr()
[getxattr*]
skip = yes

# no inotify()
[inotify*]
skip = yes

# no io_cancel()
[io_cancel*]
skip = yes

# no io_destroy()
[io_destroy*]
skip = yes

# no io_getevents()
[io_getevents*]
skip = yes

# no io_pgetevents()
[io_pgetevents*]
skip = yes

# no io_setup()
[io_setup*]
skip = yes

# no io_submit()
[io_submit*]
skip = yes

# no io_uring()
[io_uring*]
skip = yes

# runs test_ioctl, a shell script
[ioctl01_02]
skip = yes

# opens /dev/net/tun
[ioctl03]
skip = yes

# mounts a device
[ioctl04]
skip = yes

# mounts a device
[ioctl05]
skip = yes

# mounts a device
[ioctl06]
skip = yes

# no RNDGETENTCNT on /dev/urandom
[ioctl07]
skip = yes

# kernel 4.5 or newer
[ioctl08]
skip = yes

# looks for "parted" binary
[ioctl09]
skip = yes

# mounts a filesystem
[ioctl_loop*]
skip = yes

# no namespaces (/proc/self/ns, requires kernel 4.9+)
[ioctl_ns*]
skip = yes

# tries to mount a SCSI device
[ioctl_sg*]
skip = yes

# no ioperm()
[ioperm*]
skip = yes

# no iopl()
[iopl*]
skip = yes

# no ioprio_get()
[ioprio_get*]
skip = yes

# no ioprio_set()
[ioprio_set*]
skip = yes

# no kcmp()
[kcmp*]
skip = yes

# no keyctl()
[keyctl*]
skip = yes

# tries to send signal to pid 1
[kill02]
skip = yes

# opens /proc/sys/kernel/pid_max
[kill03]
skip = yes

# no shmget()
[kill05]
skip = yes

# process groups unsupported
[kill06]
skip = yes

# no shmget()
[kill07]
skip = yes

# process groups unsupported
[kill08]
skip = yes

# process groups unsupported
[kill10]
skip = yes

# no lchown()
[lchown*]
skip = yes

# no clock_gettime(CLOCK_REALTIME), adjtimex()
[leapsec01]
skip = yes

# no lgetxattr()
[lgetxattr*]
skip = yes

[link01]
skip = yes

[link02]
skip = yes

[link03]
skip = yes

[link04]
skip = yes

[link05]
skip = yes

[link06]
skip = yes

[link07]
skip = yes

[link08]
skip = yes

# no linkat()
[linkat*]
skip = yes

[listen01]
must-pass =
    1
    2

# no listxattr()
[listxattr*]
skip = yes

# no llistxattr()
[llistxattr*]
skip = yes

# tries to set RLIMIT_FSIZE and write past file size limit
[llseek01]
skip = yes

# no lremovexattr()
[lremovexattr*]
skip = yes

[lseek11]
skip = yes

[lstat01]
skip = yes

[lstat01A]
skip = yes

[lstat01A_64]
skip = yes

[lstat01_64]
skip = yes

[lstat02]
skip = yes

[lstat02_64]
skip = yes

# Requires root and `mount` syscall
[madvise01]
skip = yes

# Requires root and `mount` syscall
[madvise02]
skip = yes

# Requires /proc/sys/vm/drop_caches
[madvise06]
skip = yes

# Requires MADV_HWPOISON flag support
[madvise07]
skip = yes

# Requires prctl(PR_GET_DUMPABLE)
[madvise08]
skip = yes

# Requires cgroup support
[madvise09]
skip = yes

# Requires MADV_WIPEONFORK flag support
[madvise10]
skip = yes

# tests require libnuma
[mbind*]
skip = yes

[membarrier01]
skip = yes

# no memfd_create()
[memfd_create*]
skip = yes

# no migrate_pages(), requires libnuma
[migrate_pages*]
skip = yes

# mincore() has dummy implementation, only mincore01 passes
[mincore02]
skip = yes

[mincore03]
skip = yes

[mincore04]
skip = yes

[mkdir02]
skip = yes

[mkdir03]
skip = yes

[mkdir04]
skip = yes

[mkdir05]
skip = yes

[mkdir05A]
skip = yes

[mkdir09]
skip = yes

[mkdirat02]
skip = yes

# first two tests use supported regular files and FIFOs, other tests use unsupported char/block
# devices
[mknod01]
must-pass =
    1
    2

# requires root and uses unsupported S_ISGID
[mknod02]
skip = yes

# requires root and uses unsupported S_ISGID
[mknod03]
skip = yes

# requires root and uses unsupported S_ISGID
[mknod04]
skip = yes

# requires root and uses unsupported S_ISGID
[mknod05]
skip = yes

# requires root and wants to mount FS, also tests unsupported char, socket, and block devices
[mknod07]
skip = yes

# requires root and uses unsupported S_ISGID
[mknod08]
skip = yes

# requires root and wants to mount FS
[mknodat02]
skip = yes

[mlock01]
skip = yes

[mlock02]
skip = yes

[mlock04]
skip = yes

[mlock201]
skip = yes

[mlock202]
skip = yes

[mlock203]
skip = yes

[mlockall01]
skip = yes

[mlockall02]
skip = yes

[mlockall03]
skip = yes

[mmap01]
skip = yes

# uses siglongjmp() from exception handler back into normal execution; not supported by Graphene
[mmap05]
skip = yes

[mmap12]
skip = yes

# uses siglongjmp() from exception handler back into normal execution; not supported by Graphene
[mmap13]
skip = yes

[mmap14]
skip = yes

[mmap16]
skip = yes

# kernel 4.17 or newer
[mmap17]
skip = yes

# should fail when growing the stack over a guard page
[mmap18]
skip = yes

[modify_ldt01]
skip = yes

[modify_ldt02]
skip = yes

[modify_ldt03]
skip = yes

[mount01]
skip = yes

[mount02]
skip = yes

[mount03]
skip = yes

[mount04]
skip = yes

[mount05]
skip = yes

[mount06]
skip = yes

# no move_mount()
[move_mount*]
skip = yes

# no move_pages()
[move_pages*]
skip = yes

[mprotect01]
must-pass =
    2

# uses siglongjmp() from exception handler back into normal execution; not supported by Graphene
[mprotect04]
skip = yes

[mq_notify01]
skip = yes

[mq_notify02]
skip = yes

[mq_open01]
skip = yes

[mq_timedreceive01]
skip = yes

[mq_timedsend01]
skip = yes

[mq_unlink01]
skip = yes

[mremap01]
skip = yes

[mremap02]
skip = yes

[mremap03]
skip = yes

[mremap04]
skip = yes

[mremap05]
skip = yes

[msgctl01]
skip = yes

[msgctl02]
skip = yes

[msgctl03]
skip = yes

[msgctl04]
skip = yes

# TCONF: test requires struct msqid64_ds to have the time_high fields
[msgctl05]
skip = yes

[msgctl12]
skip = yes

[msgget02]
must-pass =
    1
    2
    3

[msgget03]
skip = yes

# kernel config
[msgget04]
skip = yes

# kernel config
[msgget05]
skip = yes

# no msgctl(IPC_STAT)
[msgrcv01]
skip = yes

[msgrcv02]
skip = yes

[msgrcv03]
skip = yes

[msgrcv05]
skip = yes

[msgrcv06]
skip = yes

[msgrcv07]
skip = yes

[msgrcv08]
skip = yes

[msgsnd01]
skip = yes

[msgsnd02]
skip = yes

# Crashes Graphene due to shim_do_msgsnd calling add_sysv_msg with src=NULL, causing NULL deref.
[msgsnd05]
skip = yes

[msgsnd06]
skip = yes

[msgstress01]
skip = yes

[msgstress02]
skip = yes

[msgstress03]
skip = yes

[msgstress04]
skip = yes

[msync01]
skip = yes

[msync02]
skip = yes

[msync03]
skip = yes

[msync04]
skip = yes

[munlock01]
skip = yes

[munlock02]
skip = yes

[munlockall01]
skip = yes

[nanosleep02]
skip = yes

[nftw01]
skip = yes

[nftw6401]
skip = yes

[nice01]
skip = yes

[nice02]
skip = yes

[nice03]
skip = yes

[nice04]
skip = yes

# Requires sticky bit support
[open01]
skip = yes

# Requires symlinks support
[open01A]
skip = yes

# Checks access/modification time, which we don't emulate currently
[open02]
skip = yes

# Requires seteuid() support
[open05]
skip = yes

# Requires support of ENXIO (fail to open for write if other side didn't open) in mknod()
[open06]
skip = yes

# Requires symlink() support
[open07]
skip = yes

# Subtest 5 requires proper file permissions checks (file with 0600 is opened using another user and
# failure is expected).
[open08]
must-pass =
    1
    2
    3
    4
    6

# Uses getpwnam("nobody") and requires "nobody" user to exist.
[open10]
skip = yes

# Uses /proc/mounts
[open11]
skip = yes

# Uses /proc/mounts
[open12]
skip = yes

# Requires touch() support
[open13]
skip = yes

# Requires O_TMPFILE support
[open14]
skip = yes

# no open_tree()
[open_tree*]
skip = yes

# Requires symlink() support
[openat02]
skip = yes

# Requires O_TMPFILE support
[openat03]
skip = yes

# no openat2()
[openat2*]
skip = yes

[pause01]
skip = yes

[pause02]
skip = yes

[pause03]
skip = yes

[perf_event_open01]
skip = yes

[perf_event_open02]
skip = yes

[personality01]
skip = yes

# no pidfd_open()
[pidfd_open*]
skip = yes

# no pidfd_send_signal()
[pidfd_send_signal*]
skip = yes

[pipe02]
skip = yes

[pipe03]
skip = yes

[pipe07]
skip = yes

[pipe11]
must-pass =
    1

# no F_GETPIPE_SZ
[pipe12]
skip = yes

# closes last writer and waits for readers to wake up, times out
[pipe13]
skip = yes

[pipe2_02]
skip = yes

# fails to set O_NONBLOCK by using pipe2(fds, O_NONBLOCK)
[pipe2_04]
skip = yes

[pivot_root01]
skip = yes

# no pkey_alloc()
[pkey*]
skip = yes

[posix_fadvise01]
skip = yes

[posix_fadvise01_64]
skip = yes

[posix_fadvise02]
skip = yes

[posix_fadvise02_64]
skip = yes

[posix_fadvise03]
skip = yes

[posix_fadvise03_64]
skip = yes

[posix_fadvise04]
skip = yes

[posix_fadvise04_64]
skip = yes

# segfault: uses sigprocmask and sends signals, broken in Graphene
[ppoll01]
skip = yes

[prctl01]
skip = yes

# no capget()
[prctl02]
skip = yes

[prctl03]
skip = yes

# no PR_GET/SET_SECCOMP
[prctl04]
skip = yes

# no PR_SET_NAME
[prctl05]
skip = yes

# mounts filesystem
[prctl06]
skip = yes

# no PR_CAMP_AMBIENT
[prctl07]
skip = yes

# no PR_TIMER_SETSLACEK
[prctl08]
skip = yes

# no PR_TIMER_SETSLACK
[prctl09]
skip = yes

[pread01]
timeout = 40

[pread01_64]
timeout = 40

[pread02]
timeout = 40

[pread03]
skip = yes

[pread03_64]
skip = yes

# Fails intermittently in CI.
[preadv01]
skip = yes

[preadv01_64]
skip = yes

[preadv02]
skip = yes

[preadv02_64]
skip = yes

[preadv03]
skip = yes

[preadv03_64]
skip = yes

[preadv201]
skip = yes

[preadv201_64]
skip = yes

[preadv202]
skip = yes

[preadv202_64]
skip = yes

# mounts filesystem
[preadv203]
skip = yes

[preadv203_64]
skip = yes

[process_vm_readv01]
skip = yes

[process_vm_readv02]
skip = yes

[process_vm_readv03]
skip = yes

[process_vm_writev01]
skip = yes

[process_vm_writev02]
skip = yes

[profil01]
skip = yes

[prot_hsymlinks]
skip = yes

# no ptrace()
[ptrace*]
skip = yes

[pwrite01_64]
timeout = 40

[pwrite03]
skip = yes

[pwrite03_64]
skip = yes

[pwrite04]
must-pass =
    2

[pwrite04_64]
timeout = 40
must-pass =
    2

[pwritev01]
skip = yes

[pwritev01_64]
skip = yes

[pwritev02]
skip = yes

[pwritev02_64]
skip = yes

[pwritev03]
skip = yes

[pwritev03_64]
skip = yes

[pwritev201]
skip = yes

[pwritev201_64]
skip = yes

[pwritev202]
skip = yes

[pwritev202_64]
skip = yes

[qmm01]
skip = yes

# no quotactl()
[quotactl*]
skip = yes

[read02]
skip = yes

[read03]
skip = yes

[readahead01]
skip = yes

[readahead02]
skip = yes

[readdir01]
timeout = 40

[readdir21]
skip = yes

[readlink01]
skip = yes

[readlink01A]
skip = yes

[readlink03]
skip = yes

[readlinkat01]
skip = yes

[readlinkat02]
skip = yes

[readv03]
skip = yes

[realpath01]
skip = yes

[reboot01]
skip = yes

[reboot02]
skip = yes

# Subtests 4 and 5 require handling MSG_OOB and MSG_ERRQUEUE flags in recv.
[recv01]
must-pass =
    1
    2
    3

# subtest 3: recvfrom(addr=-1) should return 0 (this is weird, couldn't trace this path in Linux).
# subtest 6: Requires MSG_OOB support.
# subtest 7: Requires MSG_ERRQUEUE support.
[recvfrom01]
must-pass =
    1
    2
    4
    5

# subtest 3: recvmsg01(addr=-1) should return 0 (this is weird, couldn't trace this path in Linux).
# subtest 4: Requires MSG_ERRQUEUE support.
# subtest 8: Crashes Graphene in a child process, because socket migration is totally broken. A unix
#            socket is bound in the parent and then used in the child, but because migration is
#            broken, the child uses a dangling pointer (hdl->info.sock.addr.un.dentry; actually
#            pointing to the parent's address space) and crashes in __do_accept which tries to do
#            get_dentry(sock->addr.un.dentry).
[recvmsg01]
must-pass =
    1
    2
    5
    6
    7

[recvmsg02]
skip = yes

# Requires AF_RDS support in socket().
[recvmsg03]
skip = yes

[remap_file_pages01]
skip = yes

[remap_file_pages02]
skip = yes

[removexattr01]
skip = yes

[removexattr02]
skip = yes

[rename01]
skip = yes

[rename01A]
skip = yes

[rename02]
skip = yes

[rename03]
skip = yes

[rename04]
skip = yes

[rename05]
skip = yes

[rename06]
skip = yes

[rename07]
skip = yes

[rename08]
skip = yes

[rename09]
skip = yes

[rename10]
skip = yes

[rename11]
skip = yes

[rename12]
skip = yes

[rename13]
skip = yes

[renameat01]
skip = yes

[renameat201]
skip = yes

[renameat202]
skip = yes

[request_key01]
skip = yes

[request_key02]
skip = yes

[request_key03]
skip = yes

[request_key04]
skip = yes

[request_key05]
skip = yes

[rmdir02]
skip = yes

[rmdir03]
skip = yes

[rmdir03A]
skip = yes

[rt_sigprocmask02]
skip = yes

[rt_sigqueueinfo01]
skip = yes

[rt_sigtimedwait01]
skip = yes

[rt_tgsigqueueinfo01]
skip = yes

[sbrk03]
skip = yes

[sched_getaffinity01]
must-pass =
    1
    2
    3

[sched_getattr01]
skip = yes

[sched_getattr02]
skip = yes

[sched_getparam01]
skip = yes

[sched_getparam02]
skip = yes

[sched_getparam03]
skip = yes

[sched_getscheduler01]
skip = yes

[sched_getscheduler02]
skip = yes

[sched_rr_get_interval01]
skip = yes

[sched_rr_get_interval02]
skip = yes

[sched_rr_get_interval03]
skip = yes

[sched_setaffinity01]
skip = yes

[sched_setattr01]
skip = yes

[sched_setparam01]
skip = yes

[sched_setparam02]
skip = yes

[sched_setparam03]
skip = yes

[sched_setparam04]
skip = yes

[sched_setparam05]
skip = yes

[sched_setscheduler01]
skip = yes

[sched_setscheduler02]
skip = yes

[sched_setscheduler03]
skip = yes

[select04]
timeout = 40

[semctl01]
must-pass =
    2
    3

[semctl02]
skip = yes

[semctl03]
skip = yes

[semctl04]
skip = yes

[semctl05]
skip = yes

[semctl06]
skip = yes

[semctl07]
skip = yes

# TCONF: test requires struct semid64_ds to have the time_high fields
[semctl08]
skip = yes

[semget01]
skip = yes

[semget02]
must-pass =
    2

[semget05]
skip = yes

[semget06]
skip = yes

[semop02]
skip = yes

[semop03]
skip = yes

[send01]
must-pass =
    1
    2
    3

# no MSG_MORE, send() fails with EOPNOTSUPP
[send02]
skip = yes

[sendfile02]
skip = yes

[sendfile02_64]
skip = yes

[sendfile03_64]
timeout = 40

[sendfile04]
skip = yes

[sendfile04_64]
skip = yes

[sendfile06]
skip = yes

[sendfile06_64]
skip = yes

[sendfile07]
skip = yes

[sendfile07_64]
skip = yes

[sendfile09]
skip = yes

[sendfile09_64]
skip = yes

# EINVAL from native sendmsg()
# also, shim_sendmmsg() has wrong vlen handling?
# issue: https://github.com/oscarlab/graphene/issues/1931
[sendmmsg01]
skip = yes

[sendmsg01]
skip = yes

[sendmsg02]
skip = yes

# opens /proc/sys/kernel/tainted
[sendmsg03]
skip = yes

[sendto01]
must-pass =
    1
    2
    3
    4
    7

# kernel config
[sendto03]
skip = yes

# no set_mempolicy()
[set_mempolicy*]
skip = yes

[set_thread_area01]
skip = yes

# Requires seteuid() support
[setdomainname03]
skip = yes

[setegid01]
skip = yes

[setegid02]
skip = yes

[setfsgid01]
skip = yes

[setfsgid01_16]
skip = yes

[setfsgid02]
skip = yes

[setfsgid02_16]
skip = yes

[setfsgid03]
skip = yes

[setfsgid03_16]
skip = yes

[setfsuid01]
skip = yes

[setfsuid01_16]
skip = yes

[setfsuid02]
skip = yes

[setfsuid02_16]
skip = yes

[setfsuid03]
skip = yes

[setfsuid03_16]
skip = yes

[setfsuid04]
skip = yes

[setfsuid04_16]
skip = yes

[setgid01_16]
skip = yes

[setgid02]
skip = yes

[setgid02_16]
skip = yes

[setgid03]
skip = yes

[setgid03_16]
skip = yes

[setgroups01_16]
skip = yes

[setgroups02_16]
skip = yes

[setgroups03]
must-pass =
    1

[setgroups03_16]
skip = yes

[setgroups04_16]
skip = yes

# Requires seteuid() support
[sethostname03]
skip = yes

[setitimer03]
skip = yes

[setns01]
skip = yes

[setns02]
skip = yes

[setpgid02]
skip = yes

[setpgid03]
skip = yes

[setpriority01]
skip = yes

[setpriority02]
skip = yes

# no setregid()
[setregid*]
skip = yes

# no setresgid()
[setresgid*]
skip = yes

# no setresuid()
[setresuid*]
skip = yes

# no setreuid()
[setreuid*]
skip = yes

[setrlimit01]
must-pass =
    1
    3
    4

[setrlimit02]
must-pass =
    1

[setrlimit03]
must-pass =
    2

[setrlimit04]
skip = yes

[setrlimit05]
must-pass =
    1

[setrlimit06]
skip = yes

[setsid01]
skip = yes

[setsockopt02]
skip = yes

[setsockopt03]
must-pass =
    2

# kernel config
[setsockopt05]
skip = yes

# kernel config
[setsockopt06]
skip = yes

# kernel config
[setsockopt07]
skip = yes

# no clock_settime()
[settimeofday01]
skip = yes

# no capget() (checks for CAP_SYS_TIME)
[settimeofday02]
skip = yes

[setuid01]
timeout = 40

[setuid01_16]
skip = yes

[setuid03]
skip = yes

[setuid03_16]
skip = yes

[setuid04]
skip = yes

[setuid04_16]
skip = yes

# no setxattr()
[setxattr*]
skip = yes

[sgetmask01]
skip = yes

[shmat01]
skip = yes

[shmat02]
skip = yes

[shmat03]
skip = yes

# no shmctl()
[shmctl*]
skip = yes

# no shmdt()
[shmdt*]
skip = yes

# no shmget()
[shmget*]
skip = yes

[sigaction01]
must-pass =
    4

[sigaltstack02]
timeout = 40

[sighold02]
skip = yes

[signal01]
skip = yes

# Uses inline assembly to run tkill syscall directly, which can actually abort the whole Docker
# container by sending SIGHUP to PID 1.
[signal06]
skip = yes

[signalfd01]
skip = yes

[signalfd4_01]
skip = yes

[signalfd4_02]
skip = yes

[sigpending02]
must-pass =
    1

[sigtimedwait01]
skip = yes

[sigwait01]
skip = yes

[sigwaitinfo01]
skip = yes

[socket01]
timeout = 40
must-pass =
    3
    5
    8

[socket02]
timeout = 40

# no socketcall()
[socketcall*]
skip = yes

[socketpair01]
must-pass =
    1
    5
    6

[socketpair02]
must-pass =
    1

[sockioctl01]
timeout = 40
must-pass =
    1

# no splice()
[splice*]
skip = yes

[ssetmask01]
skip = yes

[stat03]
skip = yes

[stat03_64]
skip = yes

[stat04]
skip = yes

[stat04_64]
skip = yes

# no statfs()
[statfs*]
skip = yes

# no statvfs()
[statvfs*]
skip = yes

[statx01]
skip = yes

[statx02]
skip = yes

[statx03]
skip = yes

[statx04]
skip = yes

[statx05]
skip = yes

[statx06]
skip = yes

[statx07]
skip = yes

[stime01]
skip = yes

[stime02]
skip = yes

# no swapoff()
[swapoff*]
skip = yes

# no swapon()
[swapon*]
skip = yes

[switch01]
skip = yes

# no symlink()
[symlink*]
skip = yes

# no symlinkat()
[symlinkat*]
skip = yes

[sync01]
timeout = 40

[sync03]
skip = yes

[sync_file_range01]
skip = yes

[sync_file_range02]
skip = yes

[syncfs01]
skip = yes

[syscall01]
timeout = 80

# Graphene doesn't emulate all sysconf parameters, so we disable the ones not currently emulated
[sysconf01]
must-pass =
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    12
    14
    15
    16
    17
    18
    19
    20
    21
    24
    25
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    41
    42
    44
    45
    46
    47
    48
    50
    51
    52
    53
    56

[sysctl01]
skip = yes

[sysctl03]
skip = yes

[sysctl04]
skip = yes

[sysfs01]
skip = yes

[sysfs02]
skip = yes

[sysfs03]
skip = yes

[sysfs04]
skip = yes

[sysfs05]
skip = yes

[sysfs06]
skip = yes

# no sysinfo()
[sysinfo*]
skip = yes

# most of them are shell scripts
[syslog*]
skip = yes

[tee01]
skip = yes

[tee02]
skip = yes

# timeouts on test cleanup
[tgkill01]
must-pass =
    1

# RLIMIT_SIGPENDING not supported
[tgkill02]
skip = yes

# no timer_create()
[timer_create*]
skip = yes

# no timer_delete()
[timer_delete*]
skip = yes

[timer_getoverrun01]
skip = yes

[timer_gettime01]
skip = yes

# no timer_settime()
[timer_settime*]
skip = yes

# no timerfd
[timerfd*]
skip = yes

[times03]
skip = yes

[tkill02]
skip = yes

[truncate03]
skip = yes

[truncate03_64]
skip = yes

[umask01]
skip = yes

[umount01]
skip = yes

[umount02]
skip = yes

[umount03]
skip = yes

[umount2_01]
skip = yes

[umount2_02]
skip = yes

[umount2_03]
skip = yes

# Other subtests require personality() syscall support.
[uname04]
must-pass =
    1

[unlink01]
skip = yes

[unlink05]
skip = yes

[unlink07]
skip = yes

[unlink08]
skip = yes

[unshare01]
skip = yes

[unshare02]
skip = yes

[userfaultfd01]
skip = yes

[ustat01]
skip = yes

[ustat02]
skip = yes

[utime01]
skip = yes

[utime01A]
skip = yes

[utime02]
skip = yes

[utime03]
skip = yes

[utime04]
skip = yes

[utime05]
skip = yes

[utime06]
skip = yes

[utimensat01]
skip = yes

[utimes01]
skip = yes

# requires getresuid(), currently not implemented in Graphene
[vfork01]
skip = yes

[vhangup01]
skip = yes

[vhangup02]
skip = yes

# no vmsplice()
[vmsplice*]
skip = yes

# tries to open '/proc/2/stat'
[wait401]
timeout = 40
must-pass =
    2
    3

# tries to open '/proc/sys/kernel/pid_max'
[wait402]
skip = yes

# Not supported: waitid with WSTOPPED and WCONTINUED
[waitid02]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid06]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid07]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid08]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid09]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid10]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid11]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid12]
skip = yes

# uses futexes on memory shared between processes - unsupported
[waitpid13]
skip = yes

[write02]
skip = yes

[write03]
timeout = 40

[write04]
skip = yes
